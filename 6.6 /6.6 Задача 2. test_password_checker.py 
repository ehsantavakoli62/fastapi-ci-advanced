import pytest
import os
from password_checker import is_strong_password, _load_english_words, _ENGLISH_WORDS, WORD_LIST_FILE

# Fixture to ensure words are loaded before tests and to potentially mock the word list.
# فیچر برای اطمینان از بارگذاری کلمات قبل از تست‌ها و احتمالاً Mock کردن لیست کلمات.
@pytest.fixture(autouse=True)
def setup_word_list():
    """Ensures the word list is loaded before tests run."""
    """اطمینان حاصل می‌کند که لیست کلمات قبل از اجرای تست‌ها بارگذاری شده است."""
    _load_english_words()

@pytest.fixture
def mock_word_list(monkeypatch):
    """
    Mocks the global _ENGLISH_WORDS set for specific test scenarios
    to avoid dependency on the actual file and provide controlled test data.
    
    مجموعه جهانی _ENGLISH_WORDS را برای سناریوهای تست خاص Mock می‌کند
    تا از وابستگی به فایل واقعی جلوگیری کند و داده‌های تست کنترل شده را فراهم کند.
    """
    original_words = set(_ENGLISH_WORDS) # Store original words / کلمات اصلی را ذخیره کنید
    original_loaded_status = _load_english_words._WORDS_LOADED # Store original status / وضعیت اصلی را ذخیره کنید
    
    # Clear the global set to prepare for mocking / مجموعه جهانی را برای آماده‌سازی Mock پاک کنید
    _ENGLISH_WORDS.clear()
    _load_english_words._WORDS_LOADED = False

    def set_mock_words(words_to_mock: Set[str]):
        """Helper to set specific words for the mock."""
        """کمک‌کننده برای تنظیم کلمات خاص برای Mock."""
        _ENGLISH_WORDS.update(words_to_mock)
        _load_english_words._WORDS_LOADED = True
    
    yield set_mock_words # Provide the helper function to the test / تابع کمکی را به تست ارائه دهید

    # Restore original state after test / حالت اصلی را پس از تست بازیابی کنید
    _ENGLISH_WORDS.clear()
    _ENGLISH_WORDS.update(original_words)
    _load_english_words._WORDS_LOADED = original_loaded_status


def test_strong_password_no_english_words(mock_word_list):
    """
    Test case: Password contains no English words from the disallowed list.
    مورد تست: رمز عبور حاوی هیچ کلمه انگلیسی از لیست غیرمجاز نیست.
    """
    mock_word_list({"apple", "banana"}) # Add some words to the mock list / چند کلمه به لیست Mock اضافه کنید
    assert is_strong_password("MyS3cur3P@ssw0rd") is True
    assert is_strong_password("nonenglishword_123") is True # A word not in our small mock list / کلمه‌ای که در لیست Mock کوچک ما نیست

def test_weak_password_contains_english_word(mock_word_list):
    """
    Test case: Password contains an English word from the disallowed list (case-insensitive).
    مورد تست: رمز عبور حاوی یک کلمه انگلیسی از لیست غیرمجاز است (case-insensitive).
    """
    mock_word_list({"password", "secret"})
    assert is_strong_password("MyPassword123") is False # 'password' is in it / 'password' در آن است
    assert is_strong_password("secret_sauce") is False # 'secret' is in it / 'secret' در آن است
    assert is_strong_password("AnotherSECRETword") is False # Case-insensitive / case-insensitive

def test_weak_password_contains_multi_word_phrase(mock_word_list):
    """
    Test case: Password contains multiple English words (case-insensitive).
    مورد تست: رمز عبور حاوی چندین کلمه انگلیسی است (case-insensitive).
    """
    mock_word_list({"strong", "password"})
    assert is_strong_password("ThisIsAStrongPassword") is False # Both 'strong' and 'password' / هر دو 'strong' و 'password'
    assert is_strong_password("BestSTRONGPassWordEver") is False

def test_word_length_four_or_less_ignored(mock_word_list):
    """
    Test case: English words with length 4 or less should be ignored.
    مورد تست: کلمات انگلیسی با طول 4 یا کمتر باید نادیده گرفته شوند.
    """
    mock_word_list({"test", "data", "wordy"}) # 'test' and 'data' are 4 chars, 'wordy' is 5 / 'test' و 'data' 4 کاراکتر، 'wordy' 5
    assert is_strong_password("MyTest123") is True # 'test' is length 4, should be ignored / 'test' طول 4 است، باید نادیده گرفته شود
    assert is_strong_password("SomeDATAhere") is True # 'data' is length 4, should be ignored / 'data' طول 4 است، باید نادیده گرفته شود
    assert is_strong_password("ThisIsAWordyPassword") is False # 'wordy' is length 5, should be flagged / 'wordy' طول 5 است، باید علامت‌گذاری شود

def test_non_alphabetic_characters_in_password():
    """
    Test case: Non-alphabetic characters should not interfere with word extraction.
    مورد تست: کاراکترهای غیر الفبایی نباید در استخراج کلمه تداخل ایجاد کنند.
    """
    # This test relies on the actual loaded word list (or an empty one if file not found)
    # این تست به لیست کلمات بارگذاری شده واقعی (یا یک لیست خالی در صورت عدم یافتن فایل) متکی است
    _load_english_words() # Ensure words are loaded / اطمینان حاصل کنید که کلمات بارگذاری شده‌اند
    
    # Assuming 'password' is in the loaded _ENGLISH_WORDS / با فرض اینکه 'password' در _ENGLISH_WORDS بارگذاری شده است
    if "password" in _ENGLISH_WORDS:
        assert is_strong_password("passw0rd") is False # 'passw0rd' not matched as a whole word, but 'passw' part might be tricky if not careful
        # Using regex r'\b[a-zA-Z]+\b' correctly extracts 'passw' and 'rd' separately if not for the 0.
        # It would extract 'passw' if "passw" was a word. For "passw0rd", it gets nothing or just 'passw'.
        # For this specific case: `re.findall(r'\b[a-zA-Z]+\b', "passw0rd".lower())` returns `['passw', 'rd']`
        # Using regex r'\b[a-zA-Z]+\b' به درستی 'passw' و 'rd' را به صورت جداگانه استخراج می‌کند اگر 0 نباشد.
        # اگر "passw" یک کلمه بود، "passw" را استخراج می‌کرد. برای "passw0rd"، چیزی یا فقط 'passw' را بدست می‌آورد.
        # برای این مورد خاص: `re.findall(r'\b[a-zA-Z]+\b', "passw0rd".lower())` `['passw', 'rd']` را برمی‌گرداند.
        # We need to ensure that the logic correctly handles parts of words.
        # ما باید اطمینان حاصل کنیم که منطق به درستی بخش‌هایی از کلمات را مدیریت می‌کند.
        # If 'password' is strong, 'passw0rd' should be strong too (because it's not the exact word 'password').
        # However, the problem states "does not contain *words* of English language".
        # If the extracted parts are not actual words, it's fine.
        # اگر 'password' قوی باشد، 'passw0rd' نیز باید قوی باشد (زیرا کلمه دقیق 'password' نیست).
        # با این حال، مسئله بیان می‌کند "شامل کلمات زبان انگلیسی نباشد".
        # اگر بخش‌های استخراج شده کلمات واقعی نباشند، مشکلی نیست.
        
        # This test ensures that 'passw0rd' (with a number) is not flagged as 'password'.
        # این تست تضمین می‌کند که 'passw0rd' (با یک عدد) به عنوان 'password' علامت‌گذاری نمی‌شود.
        # Assuming 'passw' and 'rd' are not full English words longer than 4 chars.
        # با فرض اینکه 'passw' و 'rd' کلمات کامل انگلیسی طولانی‌تر از 4 کاراکتر نیستند.
        
        # Let's adjust mock words to be explicit / بیایید کلمات Mock را صریحاً تنظیم کنیم
        mock_english_words = {"supersecret"}
        if "password" in _ENGLISH_WORDS:
            mock_english_words.add("password") # Add it back if it was in the original / اگر در اصلی بود، آن را اضافه کنید
        mock_word_list(mock_english_words)
        
        # 'passw0rd' should not contain 'password' / 'passw0rd' نباید شامل 'password' باشد
        # The regex `\b[a-zA-Z]+\b` will split 'passw0rd' into 'passw' and 'rd'.
        # Since 'passw' and 'rd' are unlikely to be in the dict and are short, this should pass.
        # regex `\b[a-zA-Z]+\b` 'passw0rd' را به 'passw' و 'rd' تقسیم می‌کند.
        # از آنجایی که 'passw' و 'rd' بعید است در دیکشنری باشند و کوتاه هستند، این باید پاس شود.
        assert is_strong_password("passw0rd123") is True
        assert is_strong_password("p@ssword") is False if "password" in _ENGLISH_WORDS else True # 'p' and 'ssword' - 'ssword' might be caught if >4
        # Re-evaluating: 'p@ssword' will yield 'p' and 'ssword'. 'p' is too short. 'ssword' may or may not be in dict.
        # Let's use a clear example.
        # بازبینی: 'p@ssword' 'p' و 'ssword' را تولید می‌کند. 'p' خیلی کوتاه است. 'ssword' ممکن است در دیکشنری باشد یا نباشد.
        # بیایید از یک مثال واضح استفاده کنیم.
        assert is_strong_password("Super-Secret-Password") is False if "super" in _ENGLISH_WORDS or "secret" in _ENGLISH_WORDS or "password" in _ENGLISH_WORDS else True

def test_empty_password_is_strong():
    """
    Test case: An empty password should be considered strong (as it contains no words).
    مورد تست: یک رمز عبور خالی باید قوی در نظر گرفته شود (زیرا حاوی کلمه‌ای نیست).
    """
    assert is_strong_password("") is True

def test_password_with_only_numbers_or_symbols_is_strong():
    """
    Test case: Password containing only numbers or symbols should be considered strong.
    مورد تست: رمز عبور حاوی فقط اعداد یا نمادها باید قوی در نظر گرفته شود.
    """
    assert is_strong_password("1234567890") is True
    assert is_strong_password("!@#$%^&*()") is True
    assert is_strong_password("!P@ssw0rd!") is False if "password" in _ENGLISH_WORDS else True # If 'password' is a weak word
    # For the last case, `is_strong_password("!P@ssw0rd!")` should find 'ssword' and 'p'.
    # If "ssword" is not in dict, it's strong.
    # برای مورد آخر، `is_strong_password("!P@ssw0rd!")` باید 'ssword' و 'p' را پیدا کند.
    # اگر "ssword" در دیکشنری نباشد، قوی است.
    # Let's adjust to ensure a word is found / بیایید تنظیم کنیم تا کلمه پیدا شود
    mock_word_list({"secure"})
    assert is_strong_password("My$ecureP@ssword") is False # 'secure' should be found / 'secure' باید پیدا شود


# Test for case where WORD_LIST_FILE does not exist / تست برای حالتی که WORD_LIST_FILE وجود ندارد
def test_no_word_list_file(monkeypatch):
    """
    Test case: If the word list file does not exist, the check should be bypassed
    (or return True, depending on implementation's safety).
    
    مورد تست: اگر فایل لیست کلمات وجود نداشته باشد، بررسی باید نادیده گرفته شود
    (یا True برگرداند، بسته به ایمنی پیاده‌سازی).
    """
    # Temporarily set WORD_LIST_FILE to a non-existent path / موقتاً WORD_LIST_FILE را به یک مسیر ناموجود تنظیم کنید
    monkeypatch.setattr('password_checker.WORD_LIST_FILE', '/non/existent/path/to/words.txt')
    
    # Clear and reset the loaded status to force reload / وضعیت بارگذاری شده را پاک و بازنشانی کنید تا بارگذاری مجدد اجباری شود
    _ENGLISH_WORDS.clear()
    _load_english_words._WORDS_LOADED = False
    
    # The check should return True because no words can be loaded / بررسی باید True برگرداند زیرا هیچ کلمه‌ای نمی‌تواند بارگذاری شود
    assert is_strong_password("AnyPasswordWillBeStrong") is True
    assert "WARNING: Word list file not found" in capsys.readouterr().err # Check if warning was printed / بررسی کنید که آیا هشدار چاپ شد
