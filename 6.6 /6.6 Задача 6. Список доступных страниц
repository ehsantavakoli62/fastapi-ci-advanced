#  Задача 6. Список доступных страниц


from flask import Flask, request, jsonify, render_template_string, url_for
from flask_wtf import FlaskForm
from wtforms import StringField, IntegerField, TextAreaField, PasswordField
from wtforms.validators import InputRequired, NumberRange, ValidationError, Length
from typing import Dict, Any, List, Optional
import subprocess # For running external commands / برای اجرای دستورات خارجی
import shlex # For safe shell command splitting / برای تقسیم ایمن دستورات شل
import sys # For system-specific parameters and functions / برای پارامترها و توابع خاص سیستم
import os # For interacting with the operating system / برای تعامل با سیستم عامل
import logging # For logging events / برای ثبت رویدادها
import json # For working with JSON data / برای کار با داده‌های JSON

# Import the password checker module (from Task 2) / ماژول بررسی رمز عبور را وارد کنید (از وظیفه 2)
from password_checker import is_strong_password, _load_english_words, _ENGLISH_WORDS


# --- Custom JSON Logger Adapter (from Task 3) ---
# --- آداپتور سفارشی لاگر JSON (از وظیفه 3) ---
class JsonAdapter(logging.LoggerAdapter):
    """
    A LoggerAdapter that ensures log messages are always JSON-valid by
    escaping the message content using json.dumps.
    
    یک LoggerAdapter که با escape کردن محتوای پیام با استفاده از json.dumps،
    اطمینان حاصل می‌کند که پیام‌های لاگ همیشه JSON-معتبر هستند.
    """
    def process(self, msg, kwargs):
        # Extract additional data if provided in 'extra' / داده‌های اضافی را اگر در 'extra' ارائه شده است، استخراج کنید
        extra_data = kwargs.pop('extra', {})
        
        # Create a base dictionary for the log record / یک دیکشنری پایه برای رکورد لاگ ایجاد کنید
        record_data = {
            "time": self.logger.format(logging.LogRecord(self.logger.name, 0, '', 0, '', [], None)).split(' - ')[0], # Extract time from default formatter / زمان را از فرمتر پیش‌فرض استخراج کنید
            "level": logging.getLevelName(self.level), # Get level name for the current log / نام سطح را برای لاگ فعلی بگیرید
            "message": msg # The original message / پیام اصلی
        }
        
        # Merge extra data into the record data / داده‌های اضافی را در داده‌های رکورد ادغام کنید
        record_data.update(extra_data) 
        
        # Dump the entire dictionary to a JSON string, ensuring non-ASCII characters are handled / کل دیکشنری را به یک رشته JSON تبدیل کنید و از مدیریت کاراکترهای غیر ASCII اطمینان حاصل کنید
        return json.dumps(record_data, ensure_ascii=False), kwargs


# --- Logging Configuration (from Task 3) ---
# --- پیکربندی لاگینگ (از وظیفه 3) ---

# 1. Create a logger instance / یک نمونه لاگر ایجاد کنید
base_logger = logging.getLogger(__name__) # Get a base logger for this module / یک لاگر پایه برای این ماژول بگیرید
base_logger.setLevel(logging.INFO) # Set the minimum level to INFO / حداقل سطح را روی INFO تنظیم کنید

# 2. Create a file handler for JSON logs / یک فایل هندلر برای لاگ‌های JSON ایجاد کنید
json_log_file_name = 'skillbox_json_messages.log'
if os.path.exists(json_log_file_name):
    with open(json_log_file_name, 'w'):
        pass # Clears the file content before starting the app / محتوای فایل را قبل از شروع برنامه پاک می‌کند
json_file_handler = logging.FileHandler(json_log_file_name, encoding='utf-8')

# 3. Create a formatter for the file handler. 
#    The JsonAdapter handles the JSON formatting of the message itself.
#    So, the formatter just needs to output the raw message from the adapter.
#    یک فرمتر برای فایل هندلر ایجاد کنید.
#    JsonAdapter فرمت JSON خود پیام را مدیریت می‌کند.
#    بنابراین، فرمتر فقط باید پیام خام را از آداپتور خروجی دهد.
json_formatter = logging.Formatter('%(message)s') # Just output the message, which is already JSON / فقط پیام را خروجی دهید، که از قبل JSON است

# 4. Add the formatter to the file handler / فرمتر را به فایل هندلر اضافه کنید
json_file_handler.setFormatter(json_formatter)

# 5. Add the file handler to the base logger / فایل هندلر را به لاگر پایه اضافه کنید
base_logger.addHandler(json_file_handler)

# 6. Create the JsonAdapter instance / نمونه JsonAdapter را ایجاد کنید
logger = JsonAdapter(base_logger)


# --- Flask Application Setup ---
# --- تنظیمات برنامه Flask ---
app = Flask(__name__)
app.config['SECRET_KEY'] = 'a_very_secret_key_for_code_execution_app' # Secret key for Flask-WTF forms / کلید مخفی برای فرم‌های Flask-WTF

# Pre-load English words when the Flask app starts (from Task 2) / کلمات انگلیسی را هنگام شروع برنامه Flask از پیش بارگذاری کنید (از وظیفه 2)
with app.app_context():
    _load_english_words()


# --- Helper function to check for prlimit availability (from Task 1) ---
# --- تابع کمکی برای بررسی در دسترس بودن prlimit (از وظیفه 1) ---
def is_prlimit_available() -> bool:
    """Checks if prlimit is available on the current system (Linux only). / بررسی می‌کند که آیا prlimit در سیستم فعلی (فقط لینوکس) در دسترس است."""
    return sys.platform.startswith('linux') and os.path.exists('/usr/bin/prlimit')


# --- Form Definitions (from Task 1 & 2) ---
# --- تعاریف فرم (از وظیفه 1 و 2) ---

# Form for code execution (from Task 1) / فرم برای اجرای کد (از وظیفه 1)
class CodeExecutionForm(FlaskForm):
    code = TextAreaField(
        'Python Code', 
        validators=[
            InputRequired(message="Code field cannot be empty. / فیلد کد نمی‌تواند خالی باشد."),
            Length(min=1, message="Code cannot be empty. / کد نمی‌تواند خالی باشد.")
        ]
    )
    timeout = IntegerField(
        'Timeout (seconds)', 
        validators=[
            InputRequired(message="Timeout is required. / تایم‌اوت الزامی است."),
            NumberRange(min=1, max=30, message="Timeout must be between 1 and 30 seconds. / تایم‌اوت باید بین 1 تا 30 ثانیه باشد.")
        ]
    )

# New form for password strength checking (from Task 2) / فرم جدید برای بررسی قدرت رمز عبور (از وظیفه 2)
class PasswordCheckForm(FlaskForm):
    password = PasswordField(
        'Password',
        validators=[InputRequired(message="Password cannot be empty. / رمز عبور نمی‌تواند خالی باشد."),
                    Length(min=8, message="Password must be at least 8 characters long. / رمز عبور باید حداقل 8 کاراکتر باشد.")]
    )


# --- Endpoint for Code Execution (from Task 1) ---
# --- Endpoint برای اجرای کد (از وظیفه 1) ---
@app.route('/execute_code', methods=['GET', 'POST'])
def execute_code_endpoint():
    form = CodeExecutionForm()

    if form.validate_on_submit():
        user_code = form.code.data
        timeout = form.timeout.data
        
        # Log the received request / درخواست دریافتی را لاگ کنید
        logger.info("Received code execution request.", extra={"timeout": timeout, "code_length": len(user_code)})

        cmd: List[str] = [sys.executable, "-c", user_code]

        if is_prlimit_available():
            cmd = ["prlimit", "--nproc=1:1"] + cmd
            logger.debug(f"Using prlimit: {' '.join(cmd)}") # This debug message won't be visible unless level is DEBUG / این پیام اشکال‌زدایی دیده نمی‌شود مگر اینکه سطح DEBUG باشد
        else:
            logger.warning("prlimit not available or not Linux. Proceeding without resource limits.", extra={"risk": "security_risk"})

        try:
            # Execute the user's code in a subprocess / کد کاربر را در یک زیرپروسس اجرا کنید
            process = subprocess.Popen(
                cmd, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE, 
                text=True, # Decode stdout/stderr as text / stdout/stderr را به عنوان متن رمزگشایی کنید
                shell=False # Do not use shell, pass command as list / از شل استفاده نکنید، دستور را به عنوان لیست ارسال کنید
            )
            
            # Wait for the process to complete or timeout / منتظر بمانید تا فرآیند کامل شود یا تایم‌اوت شود
            stdout_output, stderr_output = process.communicate(timeout=timeout)

            if process.returncode == 0:
                # Log successful execution / اجرای موفقیت‌آمیز را لاگ کنید
                logger.info("Code executed successfully.", extra={"output_len": len(stdout_output), "return_code": 0})
                return jsonify({
                    "status": "success",
                    "output": stdout_output.strip()
                })
            else:
                # Log execution failure / شکست اجرا را لاگ کنید
                logger.error("Code execution failed.", extra={"return_code": process.returncode, "stderr_output": stderr_output.strip()})
                return jsonify({
                    "status": "error",
                    "output": stderr_output.strip(),
                    "return_code": process.returncode
                }), 400

        except subprocess.TimeoutExpired:
            # Handle timeout / تایم‌اوت را مدیریت کنید
            process.kill() # Terminate the process / فرآیند را خاتمه دهید
            stdout_output, stderr_output = process.communicate() # Get any remaining output / خروجی‌های باقی‌مانده را دریافت کنید
            logger.warning("Code execution timed out.", extra={"timeout_seconds": timeout, "output_before_timeout": stdout_output.strip(), "error_before_timeout": stderr_output.strip()})
            return jsonify({
                "status": "timeout",
                "message": f"Code execution timed out after {timeout} seconds.",
                "output_before_timeout": stdout_output.strip(),
                "error_before_timeout": stderr_output.strip()
            }), 408
        except FileNotFoundError:
            # Handle command not found error / خطای "دستور یافت نشد" را مدیریت کنید
            logger.critical("Python interpreter or prlimit command not found. Check system PATH.", extra={"error_type": "FileNotFound"})
            return jsonify({
                "status": "error",
                "message": "Python interpreter or prlimit command not found. / مفسر پایتون یا دستور prlimit یافت نشد."
            }), 500
        except Exception as e:
            # Handle any other unexpected errors / هر خطای غیرمنتظره دیگری را مدیریت کنید
            logger.exception("An unexpected server error occurred during code execution.", extra={"exception_type": type(e).__name__, "error_message": str(e)})
            return jsonify({
                "status": "error",
                "message": f"An unexpected server error occurred: {str(e)} / یک خطای سرور غیرمنتظره رخ داد: {str(e)}"
            }), 500
    
    # Log when the form page is served or validation fails / هنگامی که صفحه فرم ارائه می‌شود یا اعتبارسنجی ناموفق است، لاگ کنید
    if request.method == 'GET':
        logger.info("Serving code execution form page.")
    else: # POST request with validation errors / درخواست POST با خطاهای اعتبارسنجی
        logger.warning("Code execution form validation failed.", extra={"errors": form.errors})

    # Render the main HTML template with forms / قالب HTML اصلی را با فرم‌ها رندر کنید
    return render_template_string("""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Python Code Executor</title>
            <style>
                body { font-family: sans-serif; margin: 2em; }
                form { background: #f9f9f9; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,.1); margin-bottom: 20px; }
                textarea, input[type="number"], input[type="password"] { width: 100%; padding: 8px; margin-top: 5px; margin-bottom: 10px; border: 1px solid #ddd; border-radius: 4px; box-sizing: border-box; }
                input[type="submit"] { background-color: #4CAF50; color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; }
                input[type="submit"]:hover { background-color: #45a049; }
                .error { color: red; font-size: 0.9em; }
                pre { background-color: #eee; padding: 10px; border-radius: 4px; overflow-x: auto; }
            </style>
        </head>
        <body>
            <h1>Execute Python Code</h1>
            <form action="/execute_code" method="POST">
                {{ form.csrf_token }}
                <p>
                    {{ form.code.label }}<br>
                    {{ form.code(rows=10, cols=80) }}
                    {% if form.code.errors %}<span class="error">{% for error in form.code.errors %}{{ error }}{% endfor %}</span>{% endif %}
                </p>
                <p>
                    {{ form.timeout.label }}<br>
                    {{ form.timeout() }}
                    {% if form.timeout.errors %}<span class="error">{% for error in form.timeout.errors %}{{ error }}{% endfor %}</span>{% endif %}
                </p>
                <p><input type="submit" value="Execute Code"></p>
            </form>

            <hr>

            <h1>Check Password Strength</h1>
            <form action="/check_password_strength" method="POST">
                {{ password_form.csrf_token }}
                <p>
                    {{ password_form.password.label }}<br>
                    {{ password_form.password() }}
                    {% if password_form.password.errors %}<span class="error">{% for error in password_form.password.errors %}{{ error }}{% endfor %}</span>{% endif %}
                </p>
                <p><input type="submit" value="Check Strength"></p>
            </form>
        </body>
        </html>
    """, form=form, password_form=PasswordCheckForm())


# --- Endpoint for Password Strength Checking (from Task 2) ---
# --- Endpoint برای بررسی قدرت رمز عبور (از وظیفه 2) ---
@app.route('/check_password_strength', methods=['POST'])
def check_password_strength_endpoint():
    password_form = PasswordCheckForm()

    if password_form.validate_on_submit():
        password = password_form.password.data
        is_strong = is_strong_password(password)
        
        # Log the password strength check result / نتیجه بررسی قدرت رمز عبور را لاگ کنید
        logger.info("Password strength check performed.", extra={"is_strong": is_strong, "password_length": len(password)})
        
        status_message = "strong" if is_strong else "weak"
        return jsonify({
            "status": "success",
            "password_strength": status_message,
            "message": f"The password is {status_message}."
        })
    else:
        # Log validation failure / شکست اعتبارسنجی را لاگ کنید
        logger.warning("Password strength check form validation failed.", extra={"errors": password_form.errors})
        return jsonify({
            "status": "error",
            "message": "Validation failed.",
            "errors": password_form.errors
        }), 400


# --- New Flask Error Handler for 404 Not Found (for Task 6) ---
# --- هندلر خطای جدید Flask برای 404 یافت نشد (برای وظیفه 6) ---
@app.errorhandler(404)
def not_found_error(error):
    """
    Custom 404 error handler that displays a list of available pages to the user.
    
    هندلر خطای 404 سفارشی که لیستی از صفحات موجود را به کاربر نمایش می‌دهد.
    """
    available_endpoints = []
    # Iterate through all URL rules registered with the Flask app.
    # تکرار از طریق تمام قوانین URL ثبت شده در برنامه Flask.
    for rule in app.url_map.iter_rules():
        # Filter out internal Flask endpoints (like 'static'), parameterized routes,
        # and ensure the method is GET (as POST endpoints aren't typically "browsable").
        # فیلتر کردن endpointهای داخلی Flask (مانند 'static')، مسیرهای پارامتریک،
        # و اطمینان از اینکه متد GET است (زیرا endpointهای POST معمولاً "قابل مرور" نیستند).
        if "GET" in rule.methods and \
           not rule.rule.startswith('/static') and \
           '<' not in rule.rule: # Exclude rules with parameters like /users/<id> / حذف قوانین دارای پارامتر مانند /users/<id>
            
            try:
                # Attempt to build URL; if it fails (e.g., due to missing parameters), skip.
                # تلاش برای ساخت URL؛ اگر ناموفق بود (مثلاً به دلیل پارامترهای از دست رفته)، رد شوید.
                with app.test_request_context(): # Create a dummy request context to use url_for / یک کانتکست درخواست ساختگی برای استفاده از url_for ایجاد کنید
                    url = url_for(rule.endpoint)
                available_endpoints.append({"endpoint": rule.endpoint, "url": url})
            except Exception:
                # If url_for fails for some reason (e.g., missing arguments for parameterized routes), just skip.
                # اگر url_for به دلایلی ناموفق بود (مثلاً آرگومان‌های از دست رفته برای مسیرهای پارامتریک)، فقط رد شوید.
                pass
    
    # Log the 404 error / خطای 404 را لاگ کنید
    logger.warning(f"404 Not Found error encountered for path: {request.path}", extra={"requested_path": request.path, "available_endpoints_count": len(available_endpoints)})

    # Render a custom 404 page with the list of available endpoints / یک صفحه 404 سفارشی با لیست endpointهای موجود رندر کنید
    return render_template_string("""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <title>Page Not Found</title>
            <style>
                body { font-family: sans-serif; margin: 2em; background-color: #f8f8f8; color: #333; }
                .container { max-width: 800px; margin: 0 auto; padding: 20px; background-color: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,.1); }
                h1 { color: #d9534f; }
                ul { list-style-type: none; padding: 0; }
                li { margin-bottom: 10px; }
                a { color: #007bff; text-decoration: none; }
                a:hover { text-decoration: underline; }
                .footer { margin-top: 30px; font-size: 0.9em; color: #777; }
            </style>
        </head>
        <body>
            <div class="container">
                <h1>404 - Page Not Found</h1>
                <p>The page you requested could not be found on the server. / صفحه درخواستی شما در سرور یافت نشد.</p>
                <p>Perhaps you were looking for one of these pages?</p>
                <h2>Available Pages:</h2>
                <ul>
                    {% for endpoint in endpoints %}
                        <li><a href="{{ endpoint.url }}">{{ endpoint.endpoint }} ({{ endpoint.url }})</a></li>
                    {% endfor %}
                </ul>
                <div class="footer">
                    <p>Skillbox Flask Application</p>
                </div>
            </div>
        </body>
        </html>
    """, endpoints=available_endpoints), 404 # Return with a 404 status code / با کد وضعیت 404 برگردانید


if __name__ == '__main__':
    app.run(debug=True)
