#  Задача 2. Удалённое исполнение кода    


import pytest
from app import app, is_prlimit_available # Import app and the helper function / app و تابع کمکی را وارد کنید
import json
import subprocess
import time
import sys

# Configure pytest to use the Flask app client / pytest را برای استفاده از کلاینت برنامه Flask پیکربندی کنید
@pytest.fixture
def client():
    """A test client for the app."""
    """یک کلاینت تست برای برنامه."""
    app.config['TESTING'] = True
    with app.test_client() as client:
        yield client

def test_code_execution_success(client):
    """
    Test case for successful code execution.
    مورد تست برای اجرای موفقیت آمیز کد.
    """
    code = "print('Hello, Skillbox!')"
    timeout = 5
    response = client.post('/execute_code', data={'code': code, 'timeout': timeout})
    
    assert response.status_code == 200
    data = json.loads(response.data)
    assert data['status'] == 'success'
    assert data['output'] == 'Hello, Skillbox!'

def test_code_execution_timeout(client):
    """
    Test case where execution time exceeds the timeout.
    مورد تست که در آن زمان اجرا از تایم‌اوت فراتر می‌رود.
    """
    # Code that sleeps for 2 seconds / کدی که 2 ثانیه می‌خوابد
    code = "import time; time.sleep(2); print('Too slow!')"
    timeout = 1 # Set timeout to 1 second / تایم‌اوت را روی 1 ثانیه تنظیم کنید
    response = client.post('/execute_code', data={'code': code, 'timeout': timeout})
    
    assert response.status_code == 408 # Expect Request Timeout / انتظار تایم‌اوت درخواست
    data = json.loads(response.data)
    assert data['status'] == 'timeout'
    assert "timed out" in data['message']
    # Check if any output was captured before timeout / بررسی کنید که آیا قبل از تایم‌اوت خروجی ضبط شده است
    assert 'output_before_timeout' in data
    assert 'error_before_timeout' in data

def test_form_validation_missing_code(client):
    """
    Test case for missing code field in the form.
    مورد تست برای فیلد کد گمشده در فرم.
    """
    response = client.post('/execute_code', data={'timeout': 5})
    
    assert response.status_code == 200 # Form validation errors usually return 200 with HTML form.
                                        # خطاهای اعتبارسنجی فرم معمولاً 200 را با فرم HTML برمی‌گردانند.
    # Check if the error message is present in the rendered HTML / بررسی کنید که آیا پیام خطا در HTML رندر شده وجود دارد
    assert b"Code field cannot be empty" in response.data
    # Or, if checking via JSON (if endpoint returns JSON on form error):
    # data = json.loads(response.data)
    # assert data['status'] == 'error'
    # assert 'code' in data['errors']

def test_form_validation_invalid_timeout_range(client):
    """
    Test case for timeout value out of range (e.g., 0 seconds).
    مورد تست برای مقدار تایم‌اوت خارج از محدوده (مثلاً 0 ثانیه).
    """
    code = "print('Test')"
    timeout = 0 # Invalid timeout / تایم‌اوت نامعتبر
    response = client.post('/execute_code', data={'code': code, 'timeout': timeout})
    
    assert response.status_code == 200 # Form validation errors usually return 200 with HTML form.
    assert b"Timeout must be between 1 and 30 seconds" in response.data

def test_form_validation_invalid_timeout_type(client):
    """
    Test case for invalid timeout type (e.g., text instead of number).
    مورد تست برای نوع تایم‌اوت نامعتبر (مثلاً متن به جای عدد).
    """
    code = "print('Test')"
    timeout = "abc" # Invalid timeout type / نوع تایم‌اوت نامعتبر
    response = client.post('/execute_code', data={'code': code, 'timeout': timeout})
    
    assert response.status_code == 200
    assert b"Not a valid integer" in response.data # WTForms' default error message / پیام خطای پیش‌فرض WTForms

@pytest.mark.skipif(sys.platform == "win32", reason="prlimit is not available on Windows")
def test_code_execution_subprocess_block(client):
    """
    Test case to verify `prlimit` (if available) prevents child processes.
    This simulates a "dangerous" code trying to spawn a subprocess.
    
    مورد تست برای بررسی اینکه `prlimit` (در صورت موجود بودن) از فرآیندهای فرزند جلوگیری می‌کند.
    این یک کد "خطرناک" را شبیه‌سازی می‌کند که سعی در ایجاد یک زیرفرآیند دارد.
    """
    # Code attempting to run another subprocess / کدی که سعی در اجرای زیرفرآیند دیگری دارد
    code = """
import subprocess
try:
    subprocess.run(['echo', 'hacked'], check=True, capture_output=True)
    print('Subprocess spawned!')
except Exception as e:
    print(f'Failed to spawn subprocess: {e}')
"""
    timeout = 5
    response = client.post('/execute_code', data={'code': code, 'timeout': timeout})
    
    assert response.status_code == 400 # Expect an error due to resource limits / انتظار خطا به دلیل محدودیت‌های منابع
    data = json.loads(response.data)
    assert data['status'] == 'error'
    # The exact error message might vary, but it should indicate a resource issue.
    # For prlimit --nproc=1:1, it often results in BlockingIOError or similar due to fork attempts.
    # پیام خطای دقیق ممکن است متفاوت باشد، اما باید نشان‌دهنده یک مشکل منابع باشد.
    # برای prlimit --nproc=1:1، اغلب به دلیل تلاش‌های fork منجر به BlockingIOError یا موارد مشابه می‌شود.
    assert ("Resource temporarily unavailable" in data['output'] or 
            "OSError: [Errno 11] Resource temporarily unavailable" in data['output'] or
            "BlockingIOError" in data['output'] or
            "failed to fork" in data['output'] or
            "cannot allocate memory" in data['output']) # Common errors when nproc is restricted / خطاهای رایج هنگام محدود شدن nproc
    print(f"Subprocess block test output: {data['output']}")


def test_code_execution_shell_injection_attempt_no_shell_true(client):
    """
    Test case for a shell injection attempt when `shell=False`.
    The `shlex.quote` on the code isn't strictly necessary when `shell=False`
    for Python's `-c` flag, but it's good practice. The core defense here is `shell=False`.
    
    مورد تست برای تلاش تزریق شل زمانی که `shell=False`.
    `shlex.quote` روی کد لزوماً زمانی که `shell=False` برای پرچم `-c` پایتون استفاده می‌شود، ضروری نیست،
    اما یک روش خوب است. دفاع اصلی در اینجا `shell=False` است.
    """
    # An attempt to inject a shell command / تلاشی برای تزریق یک دستور شل
    code = """print('Safe'); import os; os.system('echo HACKED_SHELL_INJECTION > /tmp/hacked_test.txt')"""
    timeout = 5
    response = client.post('/execute_code', data={'code': code, 'timeout': timeout})
    
    assert response.status_code == 200 # If `os.system` is called, it might succeed,
                                        # but the output won't be in our stdout/stderr
                                        # and the `prlimit` might still prevent it.
                                        # But for `shell=False` behavior of `python -c`,
                                        # `os.system` is just Python code.
                                        # If `os.system` is called, it might succeed,
                                        # but the output won't be in our stdout/stderr
                                        # and the `prlimit` might still prevent it.
                                        # But for `shell=False` behavior of `python -c`,
                                        # `os.system` is just Python code.
    data = json.loads(response.data)
    assert data['status'] == 'success' # The Python code itself executed / خود کد پایتون اجرا شد
    assert "Safe" in data['output']
    # The `os.system` would run in the child process, but its output isn't captured directly by our `communicate`.
    # `prlimit` would ideally block `os.system` from creating a new process.
    # `os.system` در فرآیند فرزند اجرا می‌شود، اما خروجی آن مستقیماً توسط `communicate` ما ضبط نمی‌شود.
    # `prlimit` ایده‌آل `os.system` را از ایجاد یک فرآیند جدید مسدود می‌کند.

    # A more direct shell injection test for `shell=True` would be:
    # cmd = f"python -c \"{code}\"; echo 'HACKED'"
    # If `shell=True` was used, `HACKED` would appear. Since it's not, we test `os.system` within the Python itself.
    # یک تست تزریق شل مستقیم‌تر برای `shell=True` این خواهد بود:
    # cmd = f"python -c \"{code}\"; echo 'HACKED'"
    # اگر `shell=True` استفاده می‌شد، `HACKED` ظاهر می‌شد. از آنجایی که استفاده نشده است، `os.system` را در خود پایتون تست می‌کنیم.
    
    # Clean up any potential file created / هر فایل بالقوه‌ای که ایجاد شده است را پاک کنید
    if os.path.exists('/tmp/hacked_test.txt'):
        os.remove('/tmp/hacked_test.txt')
        pytest.fail("Shell injection via os.system potentially succeeded!") # تزریق شل از طریق os.system به طور بالقوه موفق شد!
