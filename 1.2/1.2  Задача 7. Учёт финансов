#  Задача 7. Учёт финансов

from flask import Flask
from typing import Dict, Any

# Create an instance of the Flask application
# یک نمونه از برنامه Flask ایجاد کنید
app = Flask(__name__)

# In-memory storage for financial records.
# Structure: {year: {month: total_month_expense}}
# The problem implies we only need monthly totals, not daily.
# ذخیره‌سازی درون حافظه برای سوابق مالی.
# ساختار: {year: {month: total_month_expense}}
# مسئله به این معنی است که ما فقط به مجموع ماهانه نیاز داریم، نه روزانه.
financial_storage: Dict[int, Dict[int, int]] = {}

@app.route('/add/<string:date_str>/<int:number>')
def add_expense(date_str: str, number: int) -> str:
    """
    Adds an expense for a given date.
    Date format: YYYYMMDD. Guarantees correct format.
    
    هزینه‌ای را برای یک تاریخ مشخص اضافه می‌کند.
    قالب تاریخ: YYYYMMDD. تضمین می‌کند که قالب صحیح است.

    Args:
        date_str (str): The date in YYYYMMDD format.
        تاریخ در قالب YYYYMMDD.
        number (int): The amount of expense in rubles.
        مقدار هزینه بر حسب روبل.

    Returns:
        str: A confirmation message.
        یک پیام تأیید.
    """
    try:
        year = int(date_str[0:4])
        month = int(date_str[4:6])
        # day = int(date_str[6:8]) # Day is not needed for total month expense / روز برای مجموع هزینه ماهانه لازم نیست
        
        # Using setdefault to elegantly handle nested dictionary creation
        # استفاده از setdefault برای مدیریت زیبا ایجاد دیکشنری‌های تودرتو
        # financial_storage.setdefault(year, {}).setdefault(month, 0)
        # The above is not quite right if month needs to be dict, let's do it slightly differently
        # این بالا اگر ماه نیاز به دیکشنری داشته باشد کاملاً درست نیست، بیایید آن را کمی متفاوت انجام دهیم.
        
        # Ensure year exists / اطمینان از وجود سال
        if year not in financial_storage:
            financial_storage[year] = {}
        
        # Ensure month exists and add expense / اطمینان از وجود ماه و افزودن هزینه
        financial_storage[year][month] = financial_storage[year].get(month, 0) + number
        
        return f"Расход {number} руб. добавлен за {date_str}."
        # "Expense {number} rub. added for {date_str}."

    except (ValueError, IndexError):
        # This block should ideally not be reached if date format is guaranteed correct.
        # این بلوک ایده‌آل است اگر فرمت تاریخ تضمین شده باشد.
        return f"Ошибка: Неправильный формат даты {date_str}."
        # "Error: Invalid date format {date_str}."


@app.route('/calculate/<int:year>')
def calculate_year_expenses(year: int) -> str:
    """
    Calculates the total expenses for a specified year.
    
    کل هزینه‌ها را برای یک سال مشخص محاسبه می‌کند.

    Args:
        year (int): The year for which to calculate expenses.
        سالی که باید هزینه‌ها را برای آن محاسبه کرد.

    Returns:
        str: A message displaying the total expenses for the year.
        پیامی که کل هزینه‌ها را برای سال نمایش می‌دهد.
    """
    total_yearly_expense: int = 0
    if year in financial_storage:
        for month_expense in financial_storage[year].values():
            total_yearly_expense += month_expense
    
    return f"Суммарные траты за {year} год: {total_yearly_expense} руб."
    # "Total expenses for {year} year: {total_yearly_expense} rub."

@app.route('/calculate/<int:year>/<int:month>')
def calculate_month_expenses(year: int, month: int) -> str:
    """
    Calculates the total expenses for a specified year and month.
    
    کل هزینه‌ها را برای یک سال و ماه مشخص محاسبه می‌کند.

    Args:
        year (int): The year for which to calculate expenses.
        سالی که باید هزینه‌ها را برای آن محاسبه کرد.
        month (int): The month for which to calculate expenses (1-12).
        ماهی که باید هزینه‌ها را برای آن محاسبه کرد (1-12).

    Returns:
        str: A message displaying the total expenses for the month.
        پیامی که کل هزینه‌ها را برای ماه نمایش می‌دهد.
    """
    total_monthly_expense: int = 0
    if year in financial_storage and month in financial_storage[year]:
        total_monthly_expense = financial_storage[year][month]
    
    return f"Суммарные траты за {month:02d}.{year} год: {total_monthly_expense} руб."
    # "Total expenses for {month:02d}.{year} year: {total_monthly_expense} rub."

if __name__ == '__main__':
    # Run the Flask application in debug mode / برنامه Flask را در حالت اشکال‌زدایی اجرا کنید
    # To test:
    # 1. Add expenses:
    #    http://127.0.0.1:5000/add/20230115/100
    #    http://127.0.0.1:5000/add/20230120/50
    #    http://127.0.0.1:5000/add/20230201/200
    #    http://127.0.0.1:5000/add/20240105/300
    # 2. Calculate for a month:
    #    http://127.0.0.1:5000/calculate/2023/1  (Expected: 150)
    #    http://127.0.0.1:5000/calculate/2023/2  (Expected: 200)
    #    http://127.0.0.1:5000/calculate/2023/3  (Expected: 0)
    # 3. Calculate for a year:
    #    http://127.0.0.1:5000/calculate/2023   (Expected: 350)
    #    http://127.0.0.1:5000/calculate/2024   (Expected: 300)
    #    http://127.0.0.1:5000/calculate/2022   (Expected: 0)
    app.run(debug=True)
