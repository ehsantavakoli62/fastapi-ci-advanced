#  Задача 4. Время работы системы


from flask import Flask, request, render_template_string
from flask_wtf import FlaskForm
from wtforms import StringField, IntegerField, TextAreaField
from wtforms.validators import InputRequired, Email, Optional, ValidationError
from wtforms.fields import Field
from typing import Optional as Opt
import datetime
import subprocess # Import for running external commands / برای اجرای دستورات خارجی
import shlex      # Import for safely splitting command strings / برای تقسیم ایمن رشته‌های فرمان

# Create an instance of the Flask application
# یک نمونه از برنامه Flask ایجاد کنید
app = Flask(__name__)

# Set a secret key for Flask-WTF forms.
# یک کلید مخفی برای فرم‌های Flask-WTF تنظیم کنید.
app.config['SECRET_KEY'] = 'a_very_secret_key_for_testing_purposes_only' 

# --- Custom Validators (from Task 2) ---
# --- ولیدیتورهای سفارشی (از تمرین 2) ---

# 1. Custom validator as a function factory
# 1. ولیدیتور سفارشی به عنوان یک کارخانه تابع
def number_length(min: int, max: int, message: Opt[str] = None):
    """
    Custom validator to check if an IntegerField's value (when converted to string)
    has a length within the specified min and max range.
    
    ولیدیتور سفارشی برای بررسی اینکه آیا مقدار IntegerField (هنگامی که به رشته تبدیل می‌شود)
    طولی در محدوده حداقل و حداکثر مشخص شده دارد یا خیر.
    """
    def _number_length(form: FlaskForm, field: Field):
        if field.data is None:
            return

        try:
            num_str = str(field.data)
            length = len(num_str)
            if not (min <= length <= max):
                if message is None:
                    raise ValidationError(f"Number must be between {min} and {max} digits long. / عدد باید بین {min} و {max} رقم باشد.")
                else:
                    raise ValidationError(message)
        except ValueError:
            if message is None:
                raise ValidationError("Invalid number format. / فرمت عدد نامعتبر است.")
            else:
                raise ValidationError(message)
    return _number_length


# 2. Custom validator as a class (Included for completeness from Task 2, but not used in RegistrationForm below)
# 2. ولیدیتور سفارشی به عنوان یک کلاس (برای کامل بودن از تمرین 2 گنجانده شده است، اما در RegistrationForm زیر استفاده نمی‌شود)
class NumberLengthClass: # Renamed to avoid conflict if `number_length` function is also needed
    """
    Custom validator (class-based) to check if an IntegerField's value
    has a length within the specified min and max range.
    """
    def __init__(self, min: int, max: int, message: Opt[str] = None):
        self.min = min
        self.max = max
        self.message = message

    def __call__(self, form: FlaskForm, field: Field):
        if field.data is None:
            return

        try:
            num_str = str(field.data)
            length = len(num_str)
            if not (self.min <= length <= self.max):
                if self.message is None:
                    raise ValidationError(f"Number must be between {self.min} and {self.max} digits long (class-based). / عدد باید بین {self.min} و {self.max} رقم باشد (مبتنی بر کلاس).")
                else:
                    raise ValidationError(self.message)
        except ValueError:
            if self.message is None:
                raise ValidationError("Invalid number format (class-based). / فرمت عدد نامعتبر است (مبتنی بر کلاس).")
            else:
                raise ValidationError(self.message)


# Define the registration form with specified validators (from Task 1 & 2)
# فرم ثبت نام را با ولیدیتورهای مشخص شده تعریف کنید (از تمرین 1 و 2)
class RegistrationForm(FlaskForm):
    """
    Form for user registration, including various validators as per task requirements.
    فرم برای ثبت نام کاربر، شامل ولیدیتورهای مختلف طبق الزامات وظیفه.
    """
    email = StringField(
        'Email', 
        validators=[
            InputRequired(message="Email is required. / ایمیل الزامی است."), 
            Email(message="Invalid email format. / فرمت ایمیل نامعتبر است.")
        ]
    )
    phone = IntegerField(
        'Phone', 
        validators=[
            InputRequired(message="Phone number is required. / شماره تلفن الزامی است."),
            number_length(min=10, max=10, message="Phone number must be exactly 10 digits. / شماره تلفن باید دقیقا 10 رقم باشد."),
        ]
    )
    name = StringField(
        'Name', 
        validators=[
            InputRequired(message="Name is required. / نام الزامی است.")
        ]
    )
    address = StringField(
        'Address', 
        validators=[
            InputRequired(message="Address is required. / آدرس الزامی است.")
        ]
    )
    index = IntegerField(
        'Index', 
        validators=[
            InputRequired(message="Index is required. / کد پستی الزامی است.")
        ]
    )
    comment = TextAreaField(
        'Comment', 
        validators=[
            Optional() # This field is optional / این فیلد اختیاری است
        ]
    )

@app.route('/registration', methods=['GET', 'POST'])
def registration():
    """
    Handles user registration requests.
    درخواست‌های ثبت نام کاربر را مدیریت می‌کند.
    """
    form = RegistrationForm()
    if request.method == 'POST':
        if form.validate_on_submit():
            return "Registration successful! / ثبت نام با موفقیت انجام شد!"
        else:
            errors_list = form.errors
            return render_template_string("""
                <h1>Registration Errors / خطاهای ثبت نام</h1>
                <ul>
                    {% for field, errors in errors_list.items() %}
                        <li>{{ field }}:
                            <ul>
                                {% for error in errors %}
                                    <li>{{ error }}</li>
                                {% endfor %}
                            </ul>
                        </li>
                    {% endfor %}
                </ul>
            """, errors_list=errors_list)
    
    return render_template_string("""
        <h1>Register / ثبت نام</h1>
        <form method="POST">
            {{ form.csrf_token }} {# CSRF token for security / توکن CSRF برای امنیت #}
            <p>{{ form.email.label }}: {{ form.email() }}</p>
            <p>{{ form.phone.label }}: {{ form.phone() }}</p>
            <p>{{ form.name.label }}: {{ form.name() }}</p>
            <p>{{ form.address.label }}: {{ form.address() }}</p>
            <p>{{ form.index.label }}: {{ form.index() }}</p>
            <p>{{ form.comment.label }}: {{ form.comment() }}</p>
            <p><input type="submit" value="Register / ثبت نام"></p>
        </form>
    """, form=form)

@app.route('/uptime', methods=['GET'])
def get_uptime():
    """
    GET-endpoint that returns the system's uptime.
    Uses the 'uptime' command to fetch system uptime information.
    
    GET-endpoint که زمان فعال بودن سیستم را برمی‌گرداند.
    از دستور 'uptime' برای دریافت اطلاعات زمان فعال بودن سیستم استفاده می‌کند.
    """
    try:
        # Run the 'uptime' command. shlex.split is used for safe command parsing.
        # دستور 'uptime' را اجرا کنید. shlex.split برای تجزیه ایمن دستور استفاده می‌شود.
        command_str = "uptime -p" # '-p' flag for pretty format (e.g., 'up 1 day, 5 hours, 30 minutes')
                                  # پرچم '-p' برای فرمت زیبا (مثلاً 'up 1 day, 5 hours, 30 minutes')
        command = shlex.split(command_str)
        result = subprocess.run(command, capture_output=True, text=True, check=True)
        
        # The output from 'uptime -p' starts with "up ". We want to remove that.
        # خروجی 'uptime -p' با "up " شروع می‌شود. ما می‌خواهیم آن را حذف کنیم.
        uptime_output = result.stdout.strip()
        if uptime_output.startswith("up "):
            uptime_output = uptime_output[3:] # Remove "up " prefix / پیشوند "up " را حذف کنید

        return f"Current uptime is {uptime_output}"
    except subprocess.CalledProcessError as e:
        # Handle cases where the 'uptime' command fails (e.g., command not found)
        # موارد شکست دستور 'uptime' را مدیریت کنید (مثلاً دستور یافت نشد)
        return f"Error getting uptime: {e.stderr}", 500
    except FileNotFoundError:
        # Handle case where 'uptime' command itself is not found on the system
        # مورد یافت نشدن خود دستور 'uptime' در سیستم را مدیریت کنید
        return "Error: 'uptime' command not found on this system.", 500
    except Exception as e:
        # Catch any other unexpected errors
        # هر خطای غیرمنتظره دیگری را بگیرید
        return f"An unexpected error occurred: {e}", 500


if __name__ == '__main__':
    # Run the Flask application in debug mode for development.
    # برنامه Flask را در حالت دیباگ برای توسعه اجرا کنید.
    app.run(debug=True)
