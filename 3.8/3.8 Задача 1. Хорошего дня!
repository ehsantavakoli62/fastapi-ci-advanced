#  Задача 1. Хорошего дня!

import unittest
from flask import Flask
from freezegun import freeze_time
import datetime
import sys
import os

# Assuming app_for_task4.py is in the same directory or importable
# فرض بر این است که app_for_task4.py در همان دایرکتوری یا قابل وارد کردن است
# To make this test runnable, you might need to adjust the import path
# for 'app' and 'WEEKDAYS_RU' if they are not in the same file.
# برای اینکه این تست قابل اجرا باشد، ممکن است نیاز باشد مسیر import را
# برای 'app' و 'WEEKDAYS_RU' تنظیم کنید اگر در یک فایل نیستند.

# For this example, let's directly import from the 'app_for_task4' module.
# If your Flask app setup is complex, you might create a test client in setUpClass.
# برای این مثال، مستقیماً از ماژول 'app_for_task4' وارد می‌کنیم.
# اگر تنظیمات برنامه Flask شما پیچیده است، ممکن است یک کلاینت تست در setUpClass ایجاد کنید.

# This block attempts to import the app from the provided structure.
# If the structure is different, you might need to put the Flask app definition
# directly into this test file for simplicity or adjust the import.
try:
    # Attempt to import from the previous module's structure
    # تلاش برای وارد کردن از ساختار ماژول قبلی
    from Module25.task4.main import app, WEEKDAYS_RU, hello_world_name
except ImportError:
    # Fallback: if the above import fails, assume the app code is directly here
    # راه حل جایگزین: اگر وارد کردن بالا شکست خورد، فرض کنید کد برنامه مستقیماً در اینجا است
    print("Warning: Could not import Flask app from Module25.task4.main. Using local app definition for tests.")
    print("هشدار: نتوانستم برنامه Flask را از Module25.task4.main وارد کنم. از تعریف محلی برنامه برای تست‌ها استفاده می‌کنم.")

    app = Flask(__name__)
    WEEKDAYS_RU = (
        "понедельника",
        "вторника",
        "среды",
        "четверга",
        "пятницы",
        "субботы",
        "воскресенья"
    )

    @app.route('/hello-world/<string:name>')
    def hello_world_name(name: str) -> str:
        current_weekday_index = datetime.datetime.today().weekday()
        weekday_name_ru = WEEKDAYS_RU[current_weekday_index]
        return f"Привет, {name}. Хорошей {weekday_name_ru}!"


class TestHelloWorldEndpoint(unittest.TestCase):
    """
    Tests for the /hello-world/<name> Flask endpoint.
    
    تست‌هایی برای endpoint فلکس /hello-world/<name>.
    """
    
    @classmethod
    def setUpClass(cls) -> None:
        """
        Set up the test client for the Flask application once for all tests.
        
        کلاینت تست را برای برنامه فلکس یک بار برای تمام تست‌ها راه‌اندازی کنید.
        """
        cls.app = app.test_client()
        cls.app.testing = True

    def test_can_get_correct_username_with_weekdate(self) -> None:
        """
        Tests if the endpoint correctly returns the greeting with the provided
        username and the correct weekday for a specific date.
        
        تست می‌کند که آیا endpoint به درستی پیام خوشامدگویی را با
        نام کاربری ارائه شده و روز هفته صحیح برای یک تاریخ خاص برمی‌گرداند.
        """
        # Test each day of the week using freezegun / هر روز هفته را با freezegun تست کنید
        test_dates = [
            ("2023-01-02", "Понедельник", "понедельника"), # Monday
            ("2023-01-03", "Вторник", "вторника"),     # Tuesday
            ("2023-01-04", "Среда", "среды"),         # Wednesday
            ("2023-01-05", "Четверг", "четверга"),     # Thursday
            ("2023-01-06", "Пятница", "пятницы"),      # Friday
            ("2023-01-07", "Суббота", "субботы"),      # Saturday
            ("2023-01-08", "Воскресенье", "воскресенья") # Sunday
        ]

        for date_str, _, expected_weekday_ru in test_dates:
            with self.subTest(date=date_str): # Use subtest for clear reporting / از subtest برای گزارش‌دهی واضح استفاده کنید
                with freeze_time(date_str):
                    test_name = "Тестер" # Tester / تست‌کننده
                    expected_response_text = f"Привет, {test_name}. Хорошей {expected_weekday_ru}!"
                    
                    response = self.app.get(f'/hello-world/{test_name}')
                    self.assertEqual(response.status_code, 200)
                    self.assertEqual(response.data.decode('utf-8'), expected_response_text)

    def test_username_as_wish_for_weekday(self) -> None:
        """
        Tests if the endpoint handles a username that contains a wish for a good day,
        ensuring the returned weekday is still based on the actual date.
        
        تست می‌کند که آیا endpoint نام کاربری حاوی آرزوی یک روز خوب را مدیریت می‌کند،
        و اطمینان حاصل می‌کند که روز هفته بازگردانده شده همچنان بر اساس تاریخ واقعی است.
        """
        # Simulate a Friday / یک جمعه را شبیه‌سازی کنید
        with freeze_time("2023-11-17"): 
            test_name = "Хорошей среды" # "Good Wednesday" (but it's Friday)
                                        # "چهارشنبه خوبی داشته باشی" (اما جمعه است)
            # The system should still say "Good Friday" / سیستم همچنان باید بگوید "جمعه خوبی داشته باشی"
            expected_weekday_ru = WEEKDAYS_RU[datetime.datetime(2023, 11, 17).weekday()] # Should be 'пятницы'
            expected_response_text = f"Привет, {test_name}. Хорошей {expected_weekday_ru}!"
            
            response = self.app.get(f'/hello-world/{test_name}')
            self.assertEqual(response.status_code, 200)
            self.assertEqual(response.data.decode('utf-8'), expected_response_text)
            self.assertIn("пятницы", response.data.decode('utf-8')) # Explicitly check for 'пятницы' / صراحتاً 'пятницы' را بررسی کنید
            self.assertNotIn("среды", response.data.decode('utf-8')) # Ensure 'среды' is not in the generated weekday part / اطمینان حاصل کنید که 'среды' در بخش روز هفته تولید شده نیست

    def test_different_names(self) -> None:
        """
        Tests with different valid names.
        
        با نام‌های معتبر مختلف تست می‌کند.
        """
        with freeze_time("2023-01-05"): # Thursday / پنج‌شنبه
            expected_weekday_ru = WEEKDAYS_RU[datetime.datetime(2023, 1, 5).weekday()] # Should be 'четверга'
            
            names_to_test = ["Иван", "Мария", "Петр"]
            for name in names_to_test:
                with self.subTest(name=name):
                    expected_response_text = f"Привет, {name}. Хорошей {expected_weekday_ru}!"
                    response = self.app.get(f'/hello-world/{name}')
                    self.assertEqual(response.status_code, 200)
                    self.assertEqual(response.data.decode('utf-8'), expected_response_text)

if __name__ == '__main__':
    # Before running tests, ensure 'freezegun' is installed: pip install freezegun
    # قبل از اجرای تست‌ها، مطمئن شوید 'freezegun' نصب شده است: pip install freezegun
    unittest.main(argv=['first-arg-is-ignored'], exit=False)
