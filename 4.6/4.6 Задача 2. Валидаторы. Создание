# Задача 2. Валидаторы. Создание

from flask import Flask, request, render_template_string
from flask_wtf import FlaskForm
from wtforms import StringField, IntegerField, TextAreaField
from wtforms.validators import InputRequired, Email, Optional, ValidationError
from wtforms.fields import Field
from typing import Optional as Opt
import datetime

# Create an instance of the Flask application
# یک نمونه از برنامه Flask ایجاد کنید
app = Flask(__name__)

# Set a secret key for Flask-WTF forms.
# یک کلید مخفی برای فرم‌های Flask-WTF تنظیم کنید.
app.config['SECRET_KEY'] = 'a_very_secret_key_for_testing_purposes_only' 

# --- Custom Validators ---
# --- ولیدیتورهای سفارشی ---

# 1. Custom validator as a function factory
# 1. ولیدیتور سفارشی به عنوان یک کارخانه تابع
def number_length(min: int, max: int, message: Opt[str] = None):
    """
    Custom validator to check if an IntegerField's value (when converted to string)
    has a length within the specified min and max range.
    
    ولیدیتور سفارشی برای بررسی اینکه آیا مقدار IntegerField (هنگامی که به رشته تبدیل می‌شود)
    طولی در محدوده حداقل و حداکثر مشخص شده دارد یا خیر.

    Args:
        min (int): The minimum allowed length of the number.
                   حداقل طول مجاز عدد.
        max (int): The maximum allowed length of the number.
                   حداکثر طول مجاز عدد.
        message (Optional[str]): Custom error message. If None, a default message is used.
                                 پیام خطای سفارشی. اگر None باشد، از یک پیام پیش‌فرض استفاده می‌شود.
    """
    def _number_length(form: FlaskForm, field: Field):
        if field.data is None:
            # If the field is optional and empty, skip this validation.
            # However, InputRequired should handle required checks.
            # اگر فیلد اختیاری و خالی باشد، از این اعتبارسنجی صرف نظر کنید.
            # با این حال، InputRequired باید بررسی‌های الزامی را مدیریت کند.
            return

        try:
            num_str = str(field.data)
            length = len(num_str)
            if not (min <= length <= max):
                if message is None:
                    raise ValidationError(f"Number must be between {min} and {max} digits long. / عدد باید بین {min} و {max} رقم باشد.")
                else:
                    raise ValidationError(message)
        except ValueError:
            # This should ideally be caught by IntegerField's own type validation,
            # but as a safeguard, we ensure it's a valid number string.
            # این باید ایده‌آل توسط ولیداسیون نوع IntegerField گرفته شود،
            # اما به عنوان یک محافظ، اطمینان حاصل می‌کنیم که یک رشته عددی معتبر است.
            if message is None:
                raise ValidationError("Invalid number format. / فرمت عدد نامعتبر است.")
            else:
                raise ValidationError(message)
    return _number_length


# 2. Custom validator as a class
# 2. ولیدیتور سفارشی به عنوان یک کلاس
class NumberLength:
    """
    Custom validator (class-based) to check if an IntegerField's value
    has a length within the specified min and max range.
    
    ولیدیتور سفارشی (مبتنی بر کلاس) برای بررسی اینکه آیا مقدار IntegerField
    طولی در محدوده حداقل و حداکثر مشخص شده دارد یا خیر.
    """
    def __init__(self, min: int, max: int, message: Opt[str] = None):
        """
        Initializes the validator with min, max length and an optional message.
        ولیدیتور را با حداقل، حداکثر طول و یک پیام اختیاری مقداردهی اولیه می‌کند.
        """
        self.min = min
        self.max = max
        self.message = message

    def __call__(self, form: FlaskForm, field: Field):
        """
        The call method that performs the validation logic.
        متد فراخوانی که منطق اعتبارسنجی را انجام می‌دهد.
        """
        if field.data is None:
            # If the field is optional and empty, skip this validation.
            # اگر فیلد اختیاری و خالی باشد، از این اعتبارسنجی صرف نظر کنید.
            return

        try:
            num_str = str(field.data)
            length = len(num_str)
            if not (self.min <= length <= self.max):
                if self.message is None:
                    raise ValidationError(f"Number must be between {self.min} and {self.max} digits long (class-based). / عدد باید بین {self.min} و {self.max} رقم باشد (مبتنی بر کلاس).")
                else:
                    raise ValidationError(self.message)
        except ValueError:
            if self.message is None:
                raise ValidationError("Invalid number format (class-based). / فرمت عدد نامعتبر است (مبتنی بر کلاس).")
            else:
                raise ValidationError(self.message)


# Define the registration form with specified validators
# فرم ثبت نام را با ولیدیتورهای مشخص شده تعریف کنید
class RegistrationForm(FlaskForm):
    """
    Form for user registration, now including custom validators for the phone field.
    فرم برای ثبت نام کاربر، اکنون شامل ولیدیتورهای سفارشی برای فیلد تلفن.
    """
    email = StringField(
        'Email', 
        validators=[
            InputRequired(message="Email is required. / ایمیل الزامی است."), 
            Email(message="Invalid email format. / فرمت ایمیل نامعتبر است.")
        ]
    )
    # Using the function-based custom validator for phone
    # استفاده از ولیدیتور سفارشی مبتنی بر تابع برای فیلد تلفن
    phone = IntegerField(
        'Phone', 
        validators=[
            InputRequired(message="Phone number is required. / شماره تلفن الزامی است."),
            number_length(min=10, max=10, message="Phone number must be exactly 10 digits. / شماره تلفن باید دقیقا 10 رقم باشد."),
            # Additionally, ensure it's positive if not already covered (NumberRange implicitly covers this for 10-digit)
            # علاوه بر این، اطمینان حاصل کنید که مثبت است اگر قبلاً پوشش داده نشده باشد (NumberRange به طور ضمنی این را برای 10 رقم پوشش می‌دهد)
            # You might add NumberRange(min=0) if you only want to enforce positivity without max length
            # اگر فقط می‌خواهید مثبتی را بدون حداکثر طول اعمال کنید، ممکن است NumberRange(min=0) را اضافه کنید
        ]
    )
    # If you wanted to use the class-based validator, you would do:
    # phone_class_based = IntegerField(
    #     'Phone (Class Based)',
    #     validators=[
    #         InputRequired(message="Phone number is required."),
    #         NumberLength(min=10, max=10, message="Phone number must be exactly 10 digits (class).")
    #     ]
    # )

    name = StringField(
        'Name', 
        validators=[
            InputRequired(message="Name is required. / نام الزامی است.")
        ]
    )
    address = StringField(
        'Address', 
        validators=[
            InputRequired(message="Address is required. / آدرس الزامی است.")
        ]
    )
    index = IntegerField(
        'Index', 
        validators=[
            InputRequired(message="Index is required. / کد پستی الزامی است.")
        ]
    )
    comment = TextAreaField(
        'Comment', 
        validators=[
            Optional() # This field is optional / این فیلد اختیاری است
        ]
    )

@app.route('/registration', methods=['GET', 'POST'])
def registration():
    """
    Handles user registration requests.
    - On GET, displays the registration form.
    - On POST, validates the submitted data and returns errors or success.
    درخواست‌های ثبت نام کاربر را مدیریت می‌کند.
    - در GET، فرم ثبت نام را نمایش می‌دهد.
    - در POST، داده‌های ارسالی را اعتبارسنجی کرده و خطاها یا موفقیت را برمی‌گرداند.
    """
    form = RegistrationForm()
    if request.method == 'POST':
        if form.validate_on_submit():
            return "Registration successful! / ثبت نام با موفقیت انجام شد!"
        else:
            errors_list = form.errors
            return render_template_string("""
                <h1>Registration Errors / خطاهای ثبت نام</h1>
                <ul>
                    {% for field, errors in errors_list.items() %}
                        <li>{{ field }}:
                            <ul>
                                {% for error in errors %}
                                    <li>{{ error }}</li>
                                {% endfor %}
                            </ul>
                        </li>
                    {% endfor %}
                </ul>
            """, errors_list=errors_list)
    
    return render_template_string("""
        <h1>Register / ثبت نام</h1>
        <form method="POST">
            {{ form.csrf_token }} {# CSRF token for security / توکن CSRF برای امنیت #}
            <p>{{ form.email.label }}: {{ form.email() }}</p>
            <p>{{ form.phone.label }}: {{ form.phone() }}</p>
            <p>{{ form.name.label }}: {{ form.name() }}</p>
            <p>{{ form.address.label }}: {{ form.address() }}</p>
            <p>{{ form.index.label }}: {{ form.index() }}</p>
            <p>{{ form.comment.label }}: {{ form.comment() }}</p>
            <p><input type="submit" value="Register / ثبت نام"></p>
        </form>
    """, form=form)

if __name__ == '__main__':
    # Run the Flask application in debug mode for development.
    # برنامه Flask را در حالت دیباگ برای توسعه اجرا کنید.
    app.run(debug=True)
