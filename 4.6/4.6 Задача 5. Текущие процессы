#  Задача 5. Текущие процессы


from flask import Flask, request, render_template_string
from flask_wtf import FlaskForm
from wtforms import StringField, IntegerField, TextAreaField
from wtforms.validators import InputRequired, Email, Optional, ValidationError
from wtforms.fields import Field
from typing import Optional as Opt, List
import datetime
import subprocess # Import for running external commands / برای اجرای دستورات خارجی
import shlex      # Import for safely splitting command strings and quoting / برای تقسیم ایمن و نقل قول رشته‌های فرمان

# Create an instance of the Flask application
# یک نمونه از برنامه Flask ایجاد کنید
app = Flask(__name__)

# Set a secret key for Flask-WTF forms.
# یک کلید مخفی برای فرم‌های Flask-WTF تنظیم کنید.
app.config['SECRET_KEY'] = 'a_very_secret_key_for_testing_purposes_only' 

# --- Custom Validators (from Task 2) ---
# --- ولیدیتورهای سفارشی (از تمرین 2) ---

# Custom validator as a function factory
# ولیدیتور سفارشی به عنوان یک کارخانه تابع
def number_length(min: int, max: int, message: Opt[str] = None):
    """
    Custom validator to check if an IntegerField's value (when converted to string)
    has a length within the specified min and max range.
    ولیدیتور سفارشی برای بررسی اینکه آیا مقدار IntegerField (هنگامی که به رشته تبدیل می‌شود)
    طولی در محدوده حداقل و حداکثر مشخص شده دارد یا خیر.
    """
    def _number_length(form: FlaskForm, field: Field):
        if field.data is None:
            return

        try:
            num_str = str(field.data)
            length = len(num_str)
            if not (min <= length <= max):
                if message is None:
                    raise ValidationError(f"Number must be between {min} and {max} digits long. / عدد باید بین {min} و {max} رقم باشد.")
                else:
                    raise ValidationError(message)
        except ValueError:
            if message is None:
                raise ValidationError("Invalid number format. / فرمت عدد نامعتبر است.")
            else:
                raise ValidationError(message)
    return _number_length


# Custom validator as a class (Included for completeness from Task 2, but not used in RegistrationForm)
# ولیدیتور سفارشی به عنوان یک کلاس (برای کامل بودن از تمرین 2 گنجانده شده است، اما در RegistrationForm استفاده نمی‌شود)
class NumberLengthClass: 
    """
    Custom validator (class-based) to check if an IntegerField's value
    has a length within the specified min and max range.
    """
    def __init__(self, min: int, max: int, message: Opt[str] = None):
        self.min = min
        self.max = max
        self.message = message

    def __call__(self, form: FlaskForm, field: Field):
        if field.data is None:
            return

        try:
            num_str = str(field.data)
            length = len(num_str)
            if not (self.min <= length <= self.max):
                if self.message is None:
                    raise ValidationError(f"Number must be between {self.min} and {self.max} digits long (class-based). / عدد باید بین {self.min} و {self.max} رقم باشد (مبتنی بر کلاس).")
                else:
                    raise ValidationError(self.message)
        except ValueError:
            if self.message is None:
                raise ValidationError("Invalid number format (class-based). / فرمت عدد نامعتبر است (مبتنی بر کلاس).")
            else:
                raise ValidationError(self.message)


# Define the registration form with specified validators (from Task 1 & 2)
# فرم ثبت نام را با ولیدیتورهای مشخص شده تعریف کنید (از تمرین 1 و 2)
class RegistrationForm(FlaskForm):
    """
    Form for user registration, including various validators as per task requirements.
    فرم برای ثبت نام کاربر، شامل ولیدیتورهای مختلف طبق الزامات وظیفه.
    """
    email = StringField(
        'Email', 
        validators=[
            InputRequired(message="Email is required. / ایمیل الزامی است."), 
            Email(message="Invalid email format. / فرمت ایمیل نامعتبر است.")
        ]
    )
    phone = IntegerField(
        'Phone', 
        validators=[
            InputRequired(message="Phone number is required. / شماره تلفن الزامی است."),
            number_length(min=10, max=10, message="Phone number must be exactly 10 digits. / شماره تلفن باید دقیقا 10 رقم باشد."),
        ]
    )
    name = StringField(
        'Name', 
        validators=[
            InputRequired(message="Name is required. / نام الزامی است.")
        ]
    )
    address = StringField(
        'Address', 
        validators=[
            InputRequired(message="Address is required. / آدرس الزامی است.")
        ]
    )
    index = IntegerField(
        'Index', 
        validators=[
            InputRequired(message="Index is required. / کد پستی الزامی است.")
        ]
    )
    comment = TextAreaField(
        'Comment', 
        validators=[
            Optional() # This field is optional / این فیلد اختیاری است
        ]
    )

@app.route('/registration', methods=['GET', 'POST'])
def registration():
    """
    Handles user registration requests.
    درخواست‌های ثبت نام کاربر را مدیریت می‌کند.
    """
    form = RegistrationForm()
    if request.method == 'POST':
        if form.validate_on_submit():
            return "Registration successful! / ثبت نام با موفقیت انجام شد!"
        else:
            errors_list = form.errors
            return render_template_string("""
                <h1>Registration Errors / خطاهای ثبت نام</h1>
                <ul>
                    {% for field, errors in errors_list.items() %}
                        <li>{{ field }}:
                            <ul>
                                {% for error in errors %}
                                    <li>{{ error }}</li>
                                {% endfor %}
                            </ul>
                        </li>
                    {% endfor %}
                </ul>
            """, errors_list=errors_list)
    
    return render_template_string("""
        <h1>Register / ثبت نام</h1>
        <form method="POST">
            {{ form.csrf_token }} {# CSRF token for security / توکن CSRF برای امنیت #}
            <p>{{ form.email.label }}: {{ form.email() }}</p>
            <p>{{ form.phone.label }}: {{ form.phone() }}</p>
            <p>{{ form.name.label }}: {{ form.name() }}</p>
            <p>{{ form.address.label }}: {{ form.address() }}</p>
            <p>{{ form.index.label }}: {{ form.index() }}</p>
            <p>{{ form.comment.label }}: {{ form.comment() }}</p>
            <p><input type="submit" value="Register / ثبت نام"></p>
        </form>
    """, form=form)

@app.route('/uptime', methods=['GET'])
def get_uptime():
    """
    GET-endpoint that returns the system's uptime.
    Uses the 'uptime' command to fetch system uptime information.
    
    GET-endpoint که زمان فعال بودن سیستم را برمی‌گرداند.
    از دستور 'uptime' برای دریافت اطلاعات زمان فعال بودن سیستم استفاده می‌کند.
    """
    try:
        command_str = "uptime -p" # '-p' flag for pretty format / پرچم '-p' برای فرمت زیبا
        command = shlex.split(command_str)
        result = subprocess.run(command, capture_output=True, text=True, check=True)
        
        uptime_output = result.stdout.strip()
        if uptime_output.startswith("up "):
            uptime_output = uptime_output[3:] # Remove "up " prefix / پیشوند "up " را حذف کنید

        return f"Current uptime is {uptime_output}"
    except subprocess.CalledProcessError as e:
        return f"Error getting uptime: {e.stderr}", 500
    except FileNotFoundError:
        return "Error: 'uptime' command not found on this system.", 500
    except Exception as e:
        return f"An unexpected error occurred: {e}", 500

@app.route('/ps', methods=['GET'])
def get_ps_output():
    """
    GET-endpoint that takes command line arguments for 'ps' command
    and returns its output. Arguments are passed via 'arg' query parameter.
    
    GET-endpoint که آرگومان‌های خط فرمان را برای دستور 'ps' می‌گیرد
    و خروجی آن را برمی‌گرداند. آرگومان‌ها از طریق پارامتر کوئری 'arg' ارسال می‌شوند.
    """
    args: List[str] = request.args.getlist('arg') # Get arguments as a list / آرگومان‌ها را به عنوان لیست بگیرید

    # Sanitize each argument using shlex.quote for security.
    # We construct the command parts, then pass them as a list to subprocess.run.
    # هر آرگومان را با استفاده از shlex.quote برای امنیت ضدعفونی کنید.
    # ما قسمت‌های فرمان را می‌سازیم، سپس آن‌ها را به عنوان یک لیست به subprocess.run ارسال می‌کنیم.
    quoted_args = [shlex.quote(arg) for arg in args]
    
    # Construct the full command to execute.
    # Using 'ps' as the base command, followed by the quoted arguments.
    # دستور کامل برای اجرا را بسازید.
    # از 'ps' به عنوان دستور پایه، به دنبال آن آرگومان‌های نقل‌قول شده استفاده می‌شود.
    command = ["ps"] + quoted_args

    try:
        # Execute the 'ps' command with the sanitized arguments.
        # اجرای دستور 'ps' با آرگومان‌های ضدعفونی شده.
        result = subprocess.run(command, capture_output=True, text=True, check=True)
        
        # Format the output nicely within <pre> tags for readability.
        # خروجی را به زیبایی در تگ‌های <pre> برای خوانایی فرمت کنید.
        return f"<pre>{result.stdout}</pre>"
    except subprocess.CalledProcessError as e:
        # Handle errors if 'ps' command exits with a non-zero status.
        # خطاهای خروج دستور 'ps' با وضعیت غیر صفر را مدیریت کنید.
        return f"<pre>Error executing ps command: {e.stderr}</pre>", 500
    except FileNotFoundError:
        # Handle case where 'ps' command itself is not found on the system.
        # مورد یافت نشدن خود دستور 'ps' در سیستم را مدیریت کنید.
        return "<pre>Error: 'ps' command not found on this system.</pre>", 500
    except Exception as e:
        # Catch any other unexpected errors.
        # هر خطای غیرمنتظره دیگری را بگیرید.
        return f"<pre>An unexpected error occurred: {e}</pre>", 500


if __name__ == '__main__':
    # Run the Flask application in debug mode for development.
    # برنامه Flask را در حالت دیباگ برای توسعه اجرا کنید.
    app.run(debug=True)
