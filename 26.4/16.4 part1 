from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List
from sqlalchemy import create_engine, Column, Integer, String, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

# --- Настройка базы данных ---
DATABASE_URL = "sqlite:///./recipes.db"
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# --- Модель SQLAlchemy ---
class Recipe(Base):
    __tablename__ = "recipes"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    views = Column(Integer, default=0)
    cook_time = Column(Integer, nullable=False)
    ingredients = Column(Text, nullable=False)
    description = Column(Text, nullable=False)

Base.metadata.create_all(bind=engine)

# --- Pydantic модели ---
class RecipeBase(BaseModel):
    name: str
    cook_time: int
    ingredients: str
    description: str

class RecipeCreate(RecipeBase):
    pass

class RecipeSummary(BaseModel):
    id: int
    name: str
    views: int
    cook_time: int

    class Config:
        orm_mode = True

class RecipeDetail(RecipeSummary):
    ingredients: str
    description: str

# --- Инициализация FastAPI ---
app = FastAPI(title="Кулинарная книга API", description="API для работы с рецептами", version="1.0")

# --- Зависимость для сессии базы данных ---
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# --- Эндпоинты ---

# GET /recipes — список всех рецептов (сортировка по views, затем по cook_time)
@app.get("/recipes", response_model=List[RecipeSummary])
def get_recipes(db: SessionLocal = next(get_db())):
    recipes = db.query(Recipe).order_by(Recipe.views.desc(), Recipe.cook_time.asc()).all()
    return recipes

# GET /recipes/{recipe_id} — детальная информация по рецепту
@app.get("/recipes/{recipe_id}", response_model=RecipeDetail)
def get_recipe(recipe_id: int, db: SessionLocal = next(get_db())):
    recipe = db.query(Recipe).filter(Recipe.id == recipe_id).first()
    if not recipe:
        raise HTTPException(status_code=404, detail="Recipe not found")
    # Увеличиваем счетчик просмотров
    recipe.views += 1
    db.commit()
    db.refresh(recipe)
    return recipe

# POST /recipes — создание нового рецепта
@app.post("/recipes", response_model=RecipeDetail, status_code=201)
def create_recipe(recipe: RecipeCreate, db: SessionLocal = next(get_db())):
    db_recipe = Recipe(
        name=recipe.name,
        cook_time=recipe.cook_time,
        ingredients=recipe.ingredients,
        description=recipe.description
    )
    db.add(db_recipe)
    db.commit()
    db.refresh(db_recipe)
    return db_recipe
