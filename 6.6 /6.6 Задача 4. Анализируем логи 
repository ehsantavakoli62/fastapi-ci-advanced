#  Задача 4. Анализируем логи


import json # Import json module to work with JSON data / ماژول json را برای کار با داده‌های JSON وارد کنید
from collections import Counter # Import Counter for counting frequencies / Counter را برای شمارش فراوانی‌ها وارد کنید
from itertools import groupby # Import groupby for grouping items / groupby را برای گروه‌بندی آیتم‌ها وارد کنید
import re # Import re for regular expressions in word counting / re را برای عبارات منظم در شمارش کلمات وارد کنید
import os # Import os for file path existence check / os را برای بررسی وجود مسیر فایل وارد کنید

# --- Configuration ---
LOG_FILE_NAME = 'skillbox_json_messages.log'

def analyze_logs(log_file: str):
    """
    Analyzes a JSON log file to extract various statistics.
    The log file is read only once.
    
    یک فایل لاگ JSON را برای استخراج آمارهای مختلف تجزیه و تحلیل می‌کند.
    فایل لاگ فقط یک بار خوانده می‌شود.

    Args:
        log_file (str): The path to the JSON log file. / مسیر فایل لاگ JSON.
    """
    if not os.path.exists(log_file):
        print(f"Error: Log file '{log_file}' not found.")
        return

    parsed_logs = []
    try:
        with open(log_file, 'r', encoding='utf-8') as f:
            for line in f:
                try:
                    parsed_logs.append(json.loads(line.strip()))
                except json.JSONDecodeError as e:
                    print(f"Skipping invalid JSON line: {line.strip()} - Error: {e}")
    except Exception as e:
        print(f"Error reading log file '{log_file}': {e}")
        return

    if not parsed_logs:
        print("No valid log entries found to analyze.")
        return

    # 1. Сколько было сообщений каждого уровня за сутки.
    # 1. تعداد پیام‌های هر سطح در طول 24 ساعت.
    level_counts = Counter(log['level'] for log in parsed_logs)
    print("1. Message counts by level:")
    for level, count in level_counts.most_common():
        print(f"   {level}: {count}")

    # 2. В какой час было больше всего логов.
    # 2. در کدام ساعت بیشترین تعداد لاگ وجود داشته است.
    # Extract hour from 'time' field / ساعت را از فیلد 'time' استخراج کنید
    # Logs are assumed to be sorted by time or we group and then count
    logs_by_hour = Counter(log['time'].split(':')[0] for log in parsed_logs if 'time' in log)
    if logs_by_hour:
        most_active_hour = logs_by_hour.most_common(1)[0]
        print(f"\n2. Hour with most logs: {most_active_hour[0]}:00 (with {most_active_hour[1]} logs)")
    else:
        print("\n2. No logs with time information found.")


    # 3. Сколько логов уровня CRITICAL было в период с 05:00:00 по 05:20:00.
    # 3. تعداد لاگ‌های سطح CRITICAL در دوره 05:00:00 تا 05:20:00.
    critical_logs_in_period = [
        log for log in parsed_logs
        if log.get('level') == 'CRITICAL' and 
           'time' in log and 
           '05:00:00' <= log['time'] <= '05:20:00'
    ]
    print(f"\n3. Number of CRITICAL logs between 05:00:00 and 05:20:00: {len(critical_logs_in_period)}")

    # 4. Сколько сообщений содержат слово dog.
    # 4. تعداد پیام‌هایی که شامل کلمه 'dog' هستند.
    # Case-insensitive search for 'dog' as a whole word / جستجوی case-insensitive برای 'dog' به عنوان یک کلمه کامل
    dog_mentions = sum(1 for log in parsed_logs if 'message' in log and re.search(r'\bdog\b', log['message'], re.IGNORECASE))
    print(f"\n4. Number of messages containing the word 'dog': {dog_mentions}")

    # 5. Какое слово чаще всего встречалось в сообщениях уровня WARNING.
    # 5. کدام کلمه بیشتر در پیام‌های سطح WARNING تکرار شده است.
    warning_messages = [log['message'] for log in parsed_logs if log.get('level') == 'WARNING' and 'message' in log]
    
    all_warning_words = Counter()
    for message in warning_messages:
        # Extract all alphabetic words, convert to lowercase / تمام کلمات الفبایی را استخراج، به حروف کوچک تبدیل کنید
        words = re.findall(r'\b[a-zA-Z]+\b', message.lower())
        all_warning_words.update(words)
    
    if all_warning_words:
        most_common_warning_word = all_warning_words.most_common(1)[0]
        print(f"\n5. Most common word in WARNING messages: '{most_common_warning_word[0]}' (appeared {most_common_warning_word[1]} times)")
    else:
        print("\n5. No WARNING messages found or no words in WARNING messages.")


if __name__ == '__main__':
    analyze_logs(LOG_FILE_NAME)
