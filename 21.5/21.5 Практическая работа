# library_app_advanced.py

from datetime import datetime, timedelta
from typing import List
import csv
import io

from flask import Flask, request, jsonify
from sqlalchemy import create_engine, Column, Integer, String, Date, Float, Boolean, DateTime, ForeignKey, event, func
from sqlalchemy.orm import sessionmaker, declarative_base, relationship, Session, joinedload, selectinload
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.ext.associationproxy import association_proxy
import re # برای اعتبارسنجی شماره تلفن

# --- 1. تنظیمات پایگاه داده و ORM ---

DATABASE_URL = "sqlite:///library_advanced.db"
engine = create_engine(DATABASE_URL, echo=True) # echo=True برای دیدن کوئری‌های ORM مفید است
Base = declarative_base()
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

# --- 2. تعریف مدل‌ها با روابط و کلیدهای خارجی ---

class Author(Base):
    __tablename__ = 'authors'
    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    surname = Column(String, nullable=False)
    
    # رابطه با Book با بارگذاری selectinload
    books = relationship("Book", back_populates="author", lazy="selectin", cascade="all, delete-orphan")

class Book(Base):
    __tablename__ = 'books'
    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    count = Column(Integer, default=1)
    release_date = Column(Date, nullable=False)
    
    # کلید خارجی و رابطه با Author
    author_id = Column(Integer, ForeignKey('authors.id'), nullable=False)
    author = relationship("Author", back_populates="books")
    
    # رابطه با ReceivingBook
    receiving_books = relationship("ReceivingBook", back_populates="book", cascade="all, delete-orphan")

class Student(Base):
    __tablename__ = 'students'
    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)
    surname = Column(String, nullable=False)
    phone = Column(String, nullable=False)
    email = Column(String, nullable=False)
    average_score = Column(Float, nullable=False)
    scholarship = Column(Boolean, nullable=False)
    
    # رابطه با ReceivingBook با بارگذاری joinedload
    receiving_books = relationship("ReceivingBook", back_populates="student", lazy="joined", cascade="all, delete-orphan")
    
    # پیاده‌سازی Association Proxy: دسترسی مستقیم به لیست کتاب‌هایی که دانشجو گرفته است.
    # books_taken = association_proxy('receiving_books', 'book')
    
    @classmethod
    def get_scholarship_students(cls, session: Session) -> List['Student']:
        return session.query(cls).filter(cls.scholarship == True).all()

    @classmethod
    def get_students_by_score(cls, session: Session, min_score: float) -> List['Student']:
        return session.query(cls).filter(cls.average_score > min_score).all()

class ReceivingBook(Base):
    __tablename__ = 'receiving_books'
    id = Column(Integer, primary_key=True)
    
    # کلیدهای خارجی و روابط
    book_id = Column(Integer, ForeignKey('books.id'), nullable=False)
    student_id = Column(Integer, ForeignKey('students.id'), nullable=False)
    
    date_of_issue = Column(DateTime, nullable=False)
    date_of_return = Column(DateTime, default=None, nullable=True)
    
    # روابط
    book = relationship("Book", back_populates="receiving_books")
    student = relationship("Student", back_populates="receiving_books")

    # --- Hybrid Property: count_date_with_book ---
    @hybrid_property
    def count_date_with_book(self) -> int:
        end_date = self.date_of_return if self.date_of_return else datetime.now()
        if self.date_of_issue:
            diff = end_date - self.date_of_issue
            return diff.days
        return 0

    @count_date_with_book.expression
    def count_date_with_book(cls):
        return func.julianday(func.coalesce(cls.date_of_return, func.datetime('now'))) - func.julianday(cls.date_of_issue)

# ایجاد جداول
Base.metadata.create_all(bind=engine)

# --- 3. ORM Events (اختیاری: اعتبارسنجی شماره تلفن) ---

# الگوی regex برای شماره تلفن: +7(9**)-***-**-**
PHONE_PATTERN = re.compile(r'^\+7\(\d{3}\)-\d{3}-\d{2}-\d{2}$')

@event.listens_for(Student, 'before_insert')
@event.listens_for(Student, 'before_update')
def validate_student_phone(mapper, connection, target):
    if not PHONE_PATTERN.match(target.phone):
        raise ValueError(f"شماره تلفن {target.phone} با الگوی +7(9**)-***-**-** مطابقت ندارد.")

# --- 4. تنظیمات Flask و رووت‌ها ---

app = Flask(__name__)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# تابع کمکی برای مدیریت نشست
def use_db(f):
    def wrapper(*args, **kwargs):
        with SessionLocal() as db:
            result = f(db, *args, **kwargs)
            return result
    wrapper.__name__ = f.__name__ # حفظ نام رووت
    return wrapper


# --- رووت‌های جدید و پیچیده ---

# رووت A: دریافت موجودی کتاب بر اساس نویسنده (GET)
@app.route('/books/count_by_author/<int:author_id>', methods=['GET'])
@use_db
def get_book_count_by_author(db: Session, author_id: int):
    # کوئری: جمع کردن ستون count کتاب‌ها بر اساس author_id
    result = db.query(
        func.sum(Book.count).label('total_count')
    ).filter(Book.author_id == author_id).scalar()

    if result is None:
        return jsonify({'message': f'Author ID {author_id} not found or has no books.'}), 404
        
    return jsonify({
        'author_id': author_id, 
        'remaining_books_count': int(result)
    })

# رووت B: لیست کتاب‌هایی که دانشجو از یک نویسنده نخوانده اما کتاب دیگری از او خوانده (GET)
@app.route('/books/unread_by_author/<int:student_id>', methods=['GET'])
@use_db
def get_unread_books_by_read_author(db: Session, student_id: int):
    # 1. پیدا کردن ID نویسنده‌هایی که دانشجو از آن‌ها کتاب گرفته است
    read_author_ids = db.query(
        Book.author_id
    ).join(ReceivingBook).filter(
        ReceivingBook.student_id == student_id
    ).distinct().all()
    
    # استخراج لیست ID نویسنده‌ها
    author_ids = [a[0] for a in read_author_ids]

    if not author_ids:
        return jsonify({'message': 'Student has not taken any books yet.'}), 404

    # 2. پیدا کردن ID کتاب‌هایی که دانشجو گرفته است
    taken_book_ids = db.query(
        ReceivingBook.book_id
    ).filter(
        ReceivingBook.student_id == student_id
    ).distinct().all()

    book_ids = [b[0] for b in taken_book_ids]

    # 3. پیدا کردن تمام کتاب‌های موجود در کتابخانه از این نویسندگان
    # فیلتر: (author_id IN [author_ids]) AND (book_id NOT IN [taken_book_ids])
    unread_books = db.query(Book).options(
        joinedload(Book.author) # بارگذاری نام نویسنده برای خروجی بهتر
    ).filter(
        Book.author_id.in_(author_ids),
        Book.id.notin_(book_ids),
        Book.count > 0 # فقط کتاب‌های موجود
    ).all()

    books_data = [{
        'book_id': b.id,
        'name': b.name,
        'author': b.author.name + " " + b.author.surname
    } for b in unread_books]
    
    return jsonify({'unread_books': books_data})

# رووت C: میانگین تعداد کتاب‌های گرفته شده در این ماه (GET)
@app.route('/stats/avg_monthly_books', methods=['GET'])
@use_db
def get_avg_monthly_books(db: Session):
    today = datetime.now()
    # شروع ماه جاری
    start_of_month = datetime(today.year, today.month, 1)

    # 1. تعداد کل کتاب‌های صادر شده در این ماه
    total_issues = db.query(
        func.count(ReceivingBook.id)
    ).filter(
        ReceivingBook.date_of_issue >= start_of_month
    ).scalar()

    # 2. تعداد دانشجویان فعال
    total_students = db.query(func.count(Student.id)).scalar()

    if total_students == 0:
        return jsonify({'average_books_per_student_this_month': 0})
        
    avg_books = total_issues / total_students
    
    return jsonify({
        'total_issues_this_month': int(total_issues),
        'total_students': total_students,
        'average_books_per_student_this_month': round(avg_books, 2)
    })

# رووت D: محبوب‌ترین کتاب در میان دانشجویان با معدل بالای ۴.۰ (GET)
@app.route('/books/most_popular_high_score', methods=['GET'])
@use_db
def get_most_popular_high_score(db: Session):
    # 1. پیدا کردن ID دانشجویان با معدل بالای 4.0
    high_score_student_ids = db.query(Student.id).filter(Student.average_score > 4.0).subquery()

    # 2. کوئری اصلی: شمارش کتاب‌های گرفته شده توسط این دانشجویان
    popular_book = db.query(
        Book.name,
        func.count(ReceivingBook.book_id).label('issue_count')
    ).join(ReceivingBook).filter(
        ReceivingBook.student_id.in_(high_score_student_ids)
    ).group_by(Book.name).order_by(
        func.count(ReceivingBook.book_id).desc()
    ).first()
    
    if popular_book:
        return jsonify({
            'book_name': popular_book.name,
            'issue_count_by_high_score_students': int(popular_book.issue_count)
        })
    else:
        return jsonify({'message': 'No books issued to students with score > 4.0'}), 404

# رووت E: ТОП-۱۰ خواننده‌ترین دانشجویان در این سال (GET)
@app.route('/students/top_readers', methods=['GET'])
@use_db
def get_top_readers(db: Session):
    today = datetime.now()
    start_of_year = datetime(today.year, 1, 1)

    # کوئری: شمارش رکوردها در ReceivingBook برای هر دانشجو در سال جاری
    top_readers = db.query(
        Student.name,
        Student.surname,
        func.count(ReceivingBook.id).label('total_books_taken')
    ).join(ReceivingBook).filter(
        ReceivingBook.date_of_issue >= start_of_year
    ).group_by(
        Student.id, Student.name, Student.surname
    ).order_by(
        func.count(ReceivingBook.id).desc()
    ).limit(10).all()

    readers_data = [{
        'name': f"{s.name} {s.surname}",
        'books_taken_this_year': int(s.total_books_taken)
    } for s in top_readers]
    
    return jsonify({'top_10_readers_this_year': readers_data})

# --- رووت ۶: بارگذاری انبوه CSV (POST) ---
@app.route('/students/upload_csv', methods=['POST'])
@use_db
def upload_students_csv(db: Session):
    if 'file' not in request.files:
        return jsonify({'error': 'No file part in the request'}), 400
    
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No selected file'}), 400

    if file and file.filename.endswith('.csv'):
        # خواندن فایل به صورت متنی
        stream = io.StringIO(file.stream.read().decode("UTF8"), newline=None)
        
        # استفاده از csv.DictReader با جداکننده ;
        reader = csv.DictReader(stream, delimiter=';')
        
        students_to_insert = []
        
        try:
            for row in reader:
                # تبدیل داده‌ها به فرمت مورد نیاز مدل
                student_data = {
                    'name': row['name'],
                    'surname': row['surname'],
                    'phone': row['phone'],
                    'email': row['email'],
                    'average_score': float(row['average_score']),
                    'scholarship': row['scholarship'].lower() in ('true', '1', 'yes')
                }
                
                # این خط Session.bulk_insert_mappings() را برای درج انبوه فراخوانی می‌کند
                students_to_insert.append(student_data)
                
            if students_to_insert:
                # اجرای bulk_insert_mappings
                # این بهینه‌ترین راه برای درج تعداد زیادی رکورد است
                db.bulk_insert_mappings(Student, students_to_insert)
                db.commit()
                return jsonify({'message': f'Successfully inserted {len(students_to_insert)} students.'}), 201
            
            return jsonify({'message': 'CSV file was empty.'}), 200

        except ValueError as e:
            db.rollback()
            # این خطا شامل خطای اعتبارسنجی ORM Event نیز می‌شود
            return jsonify({'error': f'Data conversion or validation error: {str(e)}'}), 400
        except Exception as e:
            db.rollback()
            return jsonify({'error': f'An unexpected error occurred: {str(e)}'}), 500

# --- اجرای برنامه Flask ---
if __name__ == '__main__':
    # پر کردن دیتابیس با داده‌های نمونه (جهت تست)
    db = SessionLocal()
    if db.query(Book).count() == 0:
        db.add_all([
            Author(id=101, name='لئو', surname='تولستوی'), 
            Author(id=102, name='فئودور', surname='داستایوفسکی'),
            Book(id=201, name='جنگ و صلح', count=5, release_date=datetime(1869, 1, 1).date(), author_id=101),
            Book(id=202, name='آنا کارنینا', count=2, release_date=datetime(1877, 1, 1).date(), author_id=101),
            Book(id=203, name='برادران کارامازوف', count=3, release_date=datetime(1880, 1, 1).date(), author_id=102),
            Student(id=301, name='فرهاد', surname='رستمی', phone='+7(912)-345-67-89', email='f@f.com', average_score=4.1, scholarship=True),
            Student(id=302, name='نگار', surname='عابدی', phone='+7(987)-654-32-10', email='n@n.com', average_score=3.5, scholarship=False),
        ])
        db.add_all([
            # فرهاد (4.1) کتاب جنگ و صلح (تولستوی) را گرفته است
            ReceivingBook(book_id=201, student_id=301, date_of_issue=datetime.now() - timedelta(days=50)), 
            # نگار (3.5) کتاب برادران کارامازوف (داستایوفسکی) را گرفته است
            ReceivingBook(book_id=203, student_id=302, date_of_issue=datetime.now() - timedelta(days=10)) 
        ])
        db.commit()
    db.close()
    
    app.run(debug=True)
