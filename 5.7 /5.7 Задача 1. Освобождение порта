#  Задача 1. Освобождение порта 

import subprocess # For running external commands like lsof / برای اجرای دستورات خارجی مانند lsof
import os         # For system operations like killing a process / برای عملیات سیستمی مانند خاتمه دادن به یک فرآیند
import signal     # For signal constants for os.kill() / برای ثابت‌های سیگنال برای os.kill()
import time       # For sleep to allow processes to start/stop / برای sleep جهت اجازه دادن به شروع/توقف فرآیندها
import shlex      # For safe command string splitting / برای تقسیم ایمن رشته‌های فرمان
import sys        # For system-specific functionalities, like checking OS / برای قابلیت‌های خاص سیستم، مانند بررسی سیستم عامل

# --- Dummy Flask Server for testing purposes ---
# --- سرور Flask ساختگی برای اهداف تست ---
# This part represents the "server" that we want to run.
# In a real scenario, this would be your actual Flask application or any other server.
# این بخش نشان دهنده "سرور" است که ما می‌خواهیم آن را اجرا کنیم.
# در یک سناریوی واقعی، این برنامه Flask واقعی شما یا هر سرور دیگری خواهد بود.

# IMPORTANT: This Flask app is designed to run in a separate process.
# Don't try to run it directly in the same process as `run_server_on_port`.
# It's intended to be launched via `subprocess.Popen`.
# مهم: این برنامه Flask برای اجرا در یک فرآیند جداگانه طراحی شده است.
# سعی نکنید آن را مستقیماً در همان فرآیند `run_server_on_port` اجرا کنید.
# قصد دارد از طریق `subprocess.Popen` راه‌اندازی شود.

# You would typically have this in a separate file (e.g., `my_flask_app.py`)
# for a cleaner structure, but for self-contained example, it's here.
# شما معمولاً این را در یک فایل جداگانه (مثلاً `my_flask_app.py`) خواهید داشت
# برای یک ساختار تمیزتر، اما برای مثال خود شامل، در اینجا قرار دارد.

from flask import Flask # Import Flask for the dummy server / Flask را برای سرور ساختگی وارد کنید
import threading # For running Flask server in a thread (optional, but good for clean shutdown) / برای اجرای سرور Flask در یک نخ (اختیاری، اما برای خاموش شدن تمیز خوب است)

app = Flask(__name__)

@app.route('/')
def hello():
    """Simple hello world route."""
    """مسیر ساده سلام دنیا."""
    return "Hello from Flask server!"

# End of dummy Flask server part
# پایان بخش سرور Flask ساختگی
# -----------------------------------------------------------------------------

def get_pid_on_port(port: int) -> int | None:
    """
    Finds the Process ID (PID) that is listening on the given port.
    Uses 'lsof -i :<port>' on Unix-like systems.
    
    شناسه فرآیند (PID) را که در پورت داده شده گوش می‌دهد، پیدا می‌کند.
    در سیستم‌های شبه یونیکس از 'lsof -i :<port>' استفاده می‌کند.

    Args:
        port (int): The port number to check.
                    شماره پورت برای بررسی.

    Returns:
        int | None: The PID of the process, or None if no process is found.
                    PID فرآیند، یا None اگر فرآیندی یافت نشود.
    """
    if sys.platform == "win32":
        # On Windows, use 'netstat -ano | findstr :<port>'
        # در ویندوز، از 'netstat -ano | findstr :<port>' استفاده کنید
        command = f"netstat -ano | findstr :{port}"
        try:
            result = subprocess.run(
                shlex.split(command, posix=False), # posix=False for Windows command splitting / posix=False برای تقسیم دستور ویندوز
                capture_output=True, text=True, check=True, creationflags=subprocess.CREATE_NO_WINDOW
            )
            for line in result.stdout.splitlines():
                parts = line.split()
                if len(parts) > 4 and parts[1].endswith(f":{port}"):
                    try:
                        # PID is usually the last part in this netstat output / PID معمولاً آخرین قسمت در این خروجی netstat است
                        return int(parts[-1])
                    except ValueError:
                        continue
        except (subprocess.CalledProcessError, FileNotFoundError):
            return None
        
    else: # Unix-like systems (Linux, macOS) / سیستم‌های شبه یونیکس (لینوکس، macOS)
        command = f"lsof -i :{port}"
        try:
            # Use shlex.split for safety / برای ایمنی از shlex.split استفاده کنید
            result = subprocess.run(shlex.split(command), capture_output=True, text=True, check=True)
            # Example lsof output:
            # COMMAND    PID    USER  FD  TYPE    DEVICE SIZE/OFF NODE NAME
            # Python   12345    user   3u  IPv4 0x1234567      0t0  TCP *:5000 (LISTEN)
            # We need to parse the PID from the output.
            # ما باید PID را از خروجی تجزیه کنیم.
            for line in result.stdout.splitlines():
                if "LISTEN" in line and f":{port}" in line:
                    parts = line.split()
                    if len(parts) > 1:
                        try:
                            return int(parts[1])
                        except ValueError:
                            continue
        except (subprocess.CalledProcessError, FileNotFoundError):
            # lsof command not found or no process found / دستور lsof یافت نشد یا فرآیندی یافت نشد
            return None
    return None


def kill_process(pid: int) -> bool:
    """
    Terminates a process given its PID.
    
    یک فرآیند را با توجه به PID آن خاتمه می‌دهد.

    Args:
        pid (int): The Process ID to terminate.
                   شناسه فرآیند برای خاتمه دادن.

    Returns:
        bool: True if the process was successfully terminated, False otherwise.
              True اگر فرآیند با موفقیت خاتمه یافت، در غیر این صورت False.
    """
    try:
        # Send SIGTERM (terminate signal) first / ابتدا SIGTERM (سیگنال خاتمه) را ارسال کنید
        os.kill(pid, signal.SIGTERM)
        time.sleep(1) # Give process time to shut down / به فرآیند زمان برای خاموش شدن بدهید
        
        # Check if the process is still running. If so, send SIGKILL.
        # بررسی کنید که آیا فرآیند هنوز در حال اجرا است یا خیر. اگر چنین است، SIGKILL را ارسال کنید.
        # os.kill(pid, 0) checks if the process exists without sending a signal.
        # os.kill(pid, 0) بررسی می‌کند که آیا فرآیند وجود دارد یا خیر بدون ارسال سیگنال.
        if os.name == 'posix': # Unix-like systems / سیستم‌های شبه یونیکس
            try:
                os.kill(pid, 0) # Check if process exists / بررسی کنید که آیا فرآیند وجود دارد
                print(f"PID {pid} is still running after SIGTERM, sending SIGKILL...") # PID {pid} پس از SIGTERM هنوز در حال اجرا است، SIGKILL ارسال می‌شود...
                os.kill(pid, signal.SIGKILL)
                time.sleep(1)
            except OSError:
                # Process is gone / فرآیند از بین رفته است
                return True
        elif os.name == 'nt': # Windows
            # On Windows, os.kill(pid, 0) doesn't work the same.
            # We'll try to terminate again and assume success if no error.
            # در ویندوز، os.kill(pid, 0) به همان شکل کار نمی‌کند.
            # ما دوباره سعی می‌کنیم خاتمه دهیم و در صورت عدم خطا، فرض می‌کنیم موفقیت آمیز بوده است.
            # A more robust check might involve `tasklist` command.
            # یک بررسی قوی‌تر ممکن است شامل دستور `tasklist` باشد.
            return True # Assume success if SIGTERM didn't raise error / فرض موفقیت اگر SIGTERM خطایی ایجاد نکرد

        # Final check if process is still alive after SIGKILL (for posix)
        # بررسی نهایی اگر فرآیند پس از SIGKILL هنوز زنده است (برای posix)
        try:
            os.kill(pid, 0)
            print(f"Warning: PID {pid} could not be terminated.") # اخطار: PID {pid} نمی‌تواند خاتمه یابد.
            return False
        except OSError:
            return True # Process successfully terminated / فرآیند با موفقیت خاتمه یافت

    except ProcessLookupError:
        # Process already gone / فرآیند قبلاً از بین رفته است
        print(f"Process {pid} not found (already terminated or never existed).") # فرآیند {pid} یافت نشد (قبلاً خاتمه یافته یا هرگز وجود نداشته است).
        return True
    except Exception as e:
        print(f"Error killing process {pid}: {e}") # خطا در خاتمه دادن به فرآیند {pid}: {e}
        return False


def run_server_on_port(port: int, server_start_command: List[str]) -> subprocess.Popen | None:
    """
    Attempts to run a server on the specified port. If the port is busy,
    it identifies and kills the occupying process, then retries starting the server.
    
    تلاش می‌کند تا یک سرور را بر روی پورت مشخص شده اجرا کند. اگر پورت مشغول باشد،
    فرآیند اشغال‌کننده را شناسایی و خاتمه می‌دهد، سپس دوباره سعی می‌کند سرور را راه‌اندازی کند.

    Args:
        port (int): The port number to run the server on.
                    شماره پورت برای اجرای سرور.
        server_start_command (List[str]): A list of strings representing the command
                                          to start the server (e.g., ['python', 'my_flask_app.py']).
                                          لیستی از رشته‌ها که دستور راه‌اندازی سرور را نشان می‌دهد
                                          (مثلاً ['python', 'my_flask_app.py']).

    Returns:
        subprocess.Popen | None: The Popen object of the successfully started server process,
                                 or None if the server could not be started after retries.
                                 شیء Popen فرآیند سرور که با موفقیت راه‌اندازی شده است،
                                 یا None اگر سرور پس از تلاش‌های مجدد راه‌اندازی نشد.
    """
    max_retries = 2
    for attempt in range(max_retries):
        print(f"Attempt {attempt + 1}: Trying to start server on port {port}...") # تلاش {attempt + 1}: در حال تلاش برای راه‌اندازی سرور روی پورت {port}...
        
        # Check if the port is busy / بررسی کنید که آیا پورت مشغول است
        pid = get_pid_on_port(port)
        if pid:
            print(f"Port {port} is busy by process with PID {pid}.") # پورت {port} توسط فرآیند با PID {pid} مشغول است.
            if attempt < max_retries - 1: # Don't kill on the last attempt if it's already busy / در آخرین تلاش اگر پورت قبلاً مشغول است، آن را خاتمه ندهید
                print(f"Attempting to kill process {pid}...") # در حال تلاش برای خاتمه دادن به فرآیند {pid}...
                if kill_process(pid):
                    print(f"Successfully killed process {pid}.") # با موفقیت فرآیند {pid} خاتمه یافت.
                    time.sleep(2) # Give some time for the port to actually free up / کمی زمان به پورت بدهید تا واقعاً آزاد شود
                else:
                    print(f"Failed to kill process {pid}. Cannot free port {port}.") # در خاتمه دادن به فرآیند {pid} ناموفق بود. نمی‌توان پورت {port} را آزاد کرد.
                    continue # Try the next attempt without trying to start server / تلاش بعدی را بدون سعی در راه‌اندازی سرور انجام دهید
            else:
                print(f"Port {port} is still busy and max retries reached. Cannot start server.") # پورت {port} هنوز مشغول است و حداکثر تلاش‌ها انجام شده است. نمی‌توان سرور را راه‌اندازی کرد.
                return None
        
        # Try to start the server / سعی کنید سرور را راه‌اندازی کنید
        try:
            # We run the server in a separate process.
            # For Flask, this is often done by running a Python script.
            # ما سرور را در یک فرآیند جداگانه اجرا می‌کنیم.
            # برای Flask، این کار اغلب با اجرای یک اسکریپت پایتون انجام می‌شود.
            # sys.executable ensures we use the same python interpreter.
            # sys.executable تضمین می‌کند که از همان مفسر پایتون استفاده می‌کنیم.
            # Using `start_new_session=True` creates a new process group,
            # which helps prevent the child process from being killed
            # when the parent script exits.
            # استفاده از `start_new_session=True` یک گروه فرآیند جدید ایجاد می‌کند،
            # که به جلوگیری از خاتمه یافتن فرآیند فرزند هنگام خروج اسکریپت والد کمک می‌کند.
            process = subprocess.Popen(
                [sys.executable, "-c", f"from {__name__} import app; app.run(port={port}, debug=False)"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                start_new_session=True # Important for detaching the child process / مهم برای جدا کردن فرآیند فرزند
            )
            time.sleep(3) # Give server some time to start / به سرور کمی زمان برای راه‌اندازی بدهید
            
            # Check if the server actually started and is listening / بررسی کنید که آیا سرور واقعاً راه‌اندازی شده و گوش می‌دهد
            if get_pid_on_port(port):
                print(f"Server successfully started on port {port} with PID {process.pid}.") # سرور با موفقیت روی پورت {port} با PID {process.pid} راه‌اندازی شد.
                return process
            else:
                # If it didn't start, maybe it failed silently or crashed / اگر راه‌اندازی نشد، شاید بی‌صدا شکست خورده یا کرش کرده است
                print(f"Server did not appear to start on port {port}.") # سرور به نظر نمی‌رسد روی پورت {port} راه‌اندازی شده باشد.
                if process.poll() is not None: # Check if the process exited / بررسی کنید که آیا فرآیند خارج شده است
                    print(f"Server process exited with code {process.returncode}.") # فرآیند سرور با کد {process.returncode} خارج شد.
                    stderr_output = process.stderr.read().decode('utf-8', errors='ignore')
                    if stderr_output:
                        print(f"Server stderr: {stderr_output}") # خطای سرور: {stderr_output}
                else:
                    print(f"Server process is running but not listening on port {port}. Killing it.") # فرآیند سرور در حال اجرا است اما روی پورت {port} گوش نمی‌دهد. در حال خاتمه دادن آن.
                    kill_process(process.pid)
                    
        except FileNotFoundError:
            print(f"Error: Python executable '{sys.executable}' not found.") # خطا: فایل اجرایی پایتون '{sys.executable}' یافت نشد.
            return None
        except Exception as e:
            print(f"An unexpected error occurred while starting server: {e}") # یک خطای غیرمنتظره در هنگام راه‌اندازی سرور رخ داد: {e}
        
        # If server didn't start successfully, try again (if not max retries)
        # اگر سرور با موفقیت راه‌اندازی نشد، دوباره امتحان کنید (اگر به حداکثر تلاش‌ها نرسیده است)
        if attempt < max_retries - 1:
            print("Retrying in a few seconds...") # در چند ثانیه دوباره تلاش می‌شود...
            time.sleep(2)
    
    print(f"Failed to start server on port {port} after {max_retries} attempts.") # در راه‌اندازی سرور روی پورت {port} پس از {max_retries} تلاش ناموفق بود.
    return None


if __name__ == '__main__':
    # Define the port to use / پورت مورد استفاده را تعریف کنید
    TARGET_PORT = 5000 

    # Define the command to start the Flask server.
    # We are using a special command that imports `app` from THIS script itself
    # and runs it. This keeps the example self-contained.
    # دستور راه‌اندازی سرور Flask را تعریف کنید.
    # ما از یک دستور خاص استفاده می‌کنیم که `app` را از خود این اسکریپت وارد می‌کند
    # و آن را اجرا می‌کند. این کار مثال را خود شامل نگه می‌دارد.
    # Note: `__file__` is the current script's path.
    # نکته: `__file__` مسیر اسکریپت فعلی است.
    # The command runs `python -c "from free_port_and_run_server import app; app.run(port=5000, debug=False)"`
    # دستور `python -c "from free_port_and_run_server import app; app.run(port=5000, debug=False)"` را اجرا می‌کند
    # The `debug=False` is important for production or background processes.
    # `debug=False` برای فرآیندهای تولید یا پس‌زمینه مهم است.
    server_command_list = [sys.executable, "-c", f"from {os.path.basename(__file__).replace('.py', '')} import app; app.run(port={TARGET_PORT}, debug=False)"]
    
    # --- Test Scenario 1: Port is free initially ---
    # --- سناریوی تست 1: پورت در ابتدا آزاد است ---
    print("\n--- Scenario 1: Port is free initially ---")
    server_process = run_server_on_port(TARGET_PORT, server_command_list)
    if server_process:
        print(f"Server is running. You can access it at http://127.0.0.1:{TARGET_PORT}") # سرور در حال اجرا است. می‌توانید به آن در http://127.0.0.1:{TARGET_PORT} دسترسی پیدا کنید
        print("Press Ctrl+C to stop the script and server...") # برای توقف اسکریپت و سرور Ctrl+C را فشار دهید...
        try:
            # Keep the main script alive while the server runs / اسکریپت اصلی را در حین اجرای سرور زنده نگه دارید
            # In a real app, you might have a more sophisticated way to manage the child process.
            # در یک برنامه واقعی، ممکن است راه پیچیده‌تری برای مدیریت فرآیند فرزند داشته باشید.
            server_process.wait() # This waits for the server process to exit
        except KeyboardInterrupt:
            print("\nCtrl+C detected. Terminating server process.") # Ctrl+C شناسایی شد. فرآیند سرور در حال خاتمه.
            if server_process.poll() is None: # Check if it's still running / بررسی کنید که آیا هنوز در حال اجرا است
                kill_process(server_process.pid)
            print("Server stopped.") # سرور متوقف شد.
    else:
        print("Server could not be started in Scenario 1.") # سرور در سناریو 1 راه‌اندازی نشد.

    time.sleep(2) # Give some time before the next scenario / کمی زمان قبل از سناریوی بعدی بدهید

    # --- Test Scenario 2: Port is busy initially ---
    # --- سناریوی تست 2: پورت در ابتدا مشغول است ---
    print("\n--- Scenario 2: Port is busy initially ---")
    print(f"Manually starting a dummy server on port {TARGET_PORT} to simulate busy port...") # در حال راه‌اندازی دستی یک سرور ساختگی روی پورت {TARGET_PORT} برای شبیه‌سازی پورت مشغول...

    # Start a dummy process to occupy the port / یک فرآیند ساختگی برای اشغال پورت راه‌اندازی کنید
    dummy_occupying_process = subprocess.Popen(
        [sys.executable, "-c", f"from {os.path.basename(__file__).replace('.py', '')} import app; app.run(port={TARGET_PORT}, debug=False)"],
        stdout=subprocess.DEVNULL, # Redirect output to nowhere / خروجی را به جایی هدایت کنید
        stderr=subprocess.DEVNULL, # Redirect errors to nowhere / خطاها را به جایی هدایت کنید
        start_new_session=True
    )
    print(f"Dummy process started with PID: {dummy_occupying_process.pid}") # فرآیند ساختگی با PID: {dummy_occupying_process.pid} راه‌اندازی شد
    time.sleep(3) # Give it time to fully start and occupy the port / به آن زمان بدهید تا به طور کامل راه‌اندازی شده و پورت را اشغال کند

    # Now call our function, it should detect the busy port, kill the dummy, and start the actual server
    # اکنون تابع ما را فراخوانی کنید، باید پورت مشغول را شناسایی کند، ساختگی را خاتمه دهد و سرور واقعی را راه‌اندازی کند
    server_process_2 = run_server_on_port(TARGET_PORT, server_command_list)
    if server_process_2:
        print(f"Server is running after freeing port. Access at http://127.0.0.1:{TARGET_PORT}") # سرور پس از آزاد کردن پورت در حال اجرا است. دسترسی در http://127.0.0.1:{TARGET_PORT}
        print("Press Ctrl+C to stop the script and server...") # برای توقف اسکریپت و سرور Ctrl+C را فشار دهید...
        try:
            server_process_2.wait()
        except KeyboardInterrupt:
            print("\nCtrl+C detected. Terminating server process.") # Ctrl+C شناسایی شد. فرآیند سرور در حال خاتمه.
            if server_process_2.poll() is None:
                kill_process(server_process_2.pid)
            print("Server stopped.") # سرور متوقف شد.
    else:
        print("Server could not be started in Scenario 2.") # سرور در سناریو 2 راه‌اندازی نشد.
    
    # Ensure the dummy process is killed if it somehow survived (e.g., if our main process exited early)
    # اطمینان حاصل کنید که فرآیند ساختگی کشته شود اگر به نوعی زنده ماند (مثلاً اگر فرآیند اصلی ما زودتر خارج شد)
    if dummy_occupying_process.poll() is None:
        print(f"Ensuring dummy process {dummy_occupying_process.pid} is terminated.") # اطمینان از خاتمه فرآیند ساختگی {dummy_occupying_process.pid}.
        kill_process(dummy_occupying_process.pid)
